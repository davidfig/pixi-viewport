{"version":3,"file":"viewport.min.js","sources":["../src/plugins/Plugin.ts","../src/ease.ts","../src/plugins/Animate.ts","../src/plugins/Bounce.ts","../src/plugins/Clamp.ts","../src/plugins/ClampZoom.ts","../src/plugins/Decelerate.ts","../src/plugins/Drag.ts","../src/plugins/Follow.ts","../src/plugins/MouseEdges.ts","../src/plugins/Pinch.ts","../src/plugins/Snap.ts","../src/plugins/SnapZoom.ts","../src/plugins/Wheel.ts","../src/InputManager.ts","../src/PluginManager.ts","../src/Viewport.ts"],"sourcesContent":["import type { InteractionEvent } from '@pixi/interaction';\nimport type { Viewport } from '../Viewport';\n\n/**\n * Derive this class to create user-defined plugins\n *\n * @public\n */\nexport class Plugin\n{\n    /** The viewport to which this plugin is attached. */\n    public readonly parent: Viewport;\n\n    /**\n     * Flags whether this plugin has been \"paused\".\n     *\n     * @see Plugin#pause\n     * @see Plugin#resume\n     */\n    public paused: boolean;\n\n    /** @param {Viewport} parent */\n    constructor(parent: Viewport)\n    {\n        this.parent = parent;\n        this.paused = false;\n    }\n\n    /** Called when plugin is removed */\n    public destroy()\n    {\n        // Override for implementation\n    }\n\n    /** Handler for pointerdown PIXI event */\n    public down(_e: InteractionEvent): boolean\n    {\n        return false;\n    }\n\n    /** Handler for pointermove PIXI event */\n    public move(_e: InteractionEvent): boolean\n    {\n        return false;\n    }\n\n    /** Handler for pointerup PIXI event */\n    public up(_e: InteractionEvent): boolean\n    {\n        return false;\n    }\n\n    /** Handler for wheel event on div */\n    public wheel(_e: WheelEvent): boolean | undefined\n    {\n        return false;\n    }\n\n    /**\n     * Called on each tick\n     * @param {number} elapsed time in millisecond since last update\n     */\n    public update(_delta: number): void\n    {\n        // Override for implementation\n    }\n\n    /** Called when the viewport is resized */\n    public resize()\n    {\n        // Override for implementation\n    }\n\n    /** Called when the viewport is manually moved */\n    public reset(): void\n    {\n        // Override for implementation\n    }\n\n    /** Pause the plugin */\n    public pause(): void\n    {\n        this.paused = true;\n    }\n\n    /** Un-pause the plugin */\n    public resume(): void\n    {\n        this.paused = false;\n    }\n}\n","// eslint-disable-next-line\n// @ts-expect-error Penner seems to have no typings.\nimport Penner from 'penner';\n\n/**\n * Returns correct Penner equation using string or Function.\n *\n * @internal\n * @ignore\n * @param {(function|string)} [ease]\n * @param {defaults} default penner equation to use if none is provided\n */\nexport default function ease(ease: any, defaults?: any): any\n{\n    if (!ease)\n    {\n        return Penner[defaults]\n    }\n    else if (typeof ease === 'function')\n    {\n        return ease\n    }\n    else if (typeof ease === 'string')\n    {\n        return Penner[ease]\n    }\n}","import { Point } from '@pixi/math';\nimport { Plugin } from './Plugin';\nimport ease from '../ease';\n\nimport type { Viewport } from '../Viewport';\n\n/** Options for {@link Animate}. */\nexport interface IAnimateOptions {\n    /** Time to animate */\n    time?: number;\n\n    /** Position to move the viewport to */\n    position?: Point;\n\n    /**\n     * Desired viewport width in world pixels\n     *\n     * (use instead of scale; aspect ratio is maintained if height is not provided)\n     */\n    width?: number;\n\n    /**\n     * Desired viewport height in world pixels\n     *\n     * (use instead of scale; aspect ratio is maintained if width is not provided)\n     */\n    height?: number;\n\n    /** Scale to change zoom (scale.x = scale.y) */\n    scale?: number;\n\n    /** Independently change zoom in x-direction */\n    scaleX?: number;\n\n    /** Independently change zoom in y-direction */\n    scaleY?: number;\n\n    /** Easing function to use */\n    ease?: any;\n\n    /** Callback to invoke when the animation completes */\n    callbackOnComplete?: (viewport: Viewport) => void;\n\n    /** Removes this plugin if interrupted by any user input */\n    removeOnInterrupt?: boolean;\n}\n\nconst DEFAULT_ANIMATE_OPTIONS = {\n    removeOnInterrupt: false,\n    ease: 'linear',\n    time: 1000,\n};\n\n/**\n * Animation plugin.\n *\n * @see Viewport#animate\n * @fires animate-end\n */\nexport class Animate extends Plugin\n{\n    public readonly options: IAnimateOptions & { ease: any; time: number };\n\n    /** The starting x-coordinate of the viewport. */\n    protected startX?: number;\n\n    /** The starting y-coordinate of the viewport. */\n    protected startY?: number;\n\n    /** The change in the x-coordinate of the viewport through the animation.*/\n    protected deltaX?: number;\n\n    /** The change in the y-coordinate of the viewport through the animation. */\n    protected deltaY?: number;\n\n    /** Marks whether the center of the viewport is preserved in the animation. */\n    protected keepCenter!: boolean;\n\n    /** The starting viewport width. */\n    protected startWidth: number | null = null;\n\n    /** The starting viewport height. */\n    protected startHeight: number | null = null;\n\n    /** The change in the viewport's width through the animation. */\n    protected deltaWidth: number | null = null;\n\n    /** The change in the viewport's height through the animation. */\n    protected deltaHeight: number | null = null;\n\n    /** The viewport's width post-animation. */\n    protected width: number | null = null;\n\n    /** The viewport's height post-animation. */\n    protected height: number | null = null;\n\n    /** The time since the animation started. */\n    protected time = 0;\n\n    /**\n     * This is called by {@link Viewport.animate}.\n     *\n     * @param parent\n     * @param options\n     */\n    constructor(parent: Viewport, options: IAnimateOptions = {})\n    {\n        super(parent);\n\n        this.options = Object.assign({}, DEFAULT_ANIMATE_OPTIONS, options);\n        this.options.ease = ease(this.options.ease);\n\n        this.setupPosition();\n        this.setupZoom();\n\n        this.time = 0;\n    }\n\n    /**\n     * Setup `startX`, `startY`, `deltaX`, `deltaY`, `keepCenter`.\n     *\n     * This is called during construction.\n     */\n    protected setupPosition(): void\n    {\n        if (typeof this.options.position !== 'undefined')\n        {\n            this.startX = this.parent.center.x;\n            this.startY = this.parent.center.y;\n            this.deltaX = this.options.position.x - this.parent.center.x;\n            this.deltaY = this.options.position.y - this.parent.center.y;\n            this.keepCenter = false;\n        }\n        else\n        {\n            this.keepCenter = true;\n        }\n    }\n\n    /**\n     * Setup `startWidth, `startHeight`, `deltaWidth, `deltaHeight, `width`, `height`.\n     *\n     * This is called during construction.\n     */\n    protected setupZoom(): void\n    {\n        this.width = null;\n        this.height = null;\n\n        if (typeof this.options.scale !== 'undefined')\n        {\n            this.width = this.parent.screenWidth / this.options.scale;\n        }\n        else if (typeof this.options.scaleX !== 'undefined' || typeof this.options.scaleY !== 'undefined')\n        {\n            if (typeof this.options.scaleX !== 'undefined')\n            {\n                // screenSizeInWorldPixels = screenWidth / scale\n                this.width = this.parent.screenWidth / this.options.scaleX;\n            }\n            if (typeof this.options.scaleY !== 'undefined')\n            {\n                this.height = this.parent.screenHeight / this.options.scaleY;\n            }\n        }\n        else\n        {\n            if (typeof this.options.width !== 'undefined')\n            {\n                this.width = this.options.width;\n            }\n            if (typeof this.options.height !== 'undefined')\n            {\n                this.height = this.options.height;\n            }\n        }\n\n        if (this.width !== null)\n        {\n            this.startWidth = this.parent.screenWidthInWorldPixels;\n            this.deltaWidth = this.width - this.startWidth;\n        }\n        if (this.height !== null)\n        {\n            this.startHeight = this.parent.screenHeightInWorldPixels;\n            this.deltaHeight = this.height - this.startHeight;\n        }\n    }\n\n    public down(): boolean\n    {\n        if (this.options.removeOnInterrupt)\n        {\n            this.parent.plugins.remove('animate');\n        }\n\n        return false;\n    }\n\n    public complete(): void\n    {\n        this.parent.plugins.remove('animate');\n        if (this.width !== null)\n        {\n            this.parent.fitWidth(this.width, this.keepCenter, this.height === null);\n        }\n        if (this.height !== null)\n        {\n            this.parent.fitHeight(this.height, this.keepCenter, this.width === null);\n        }\n        if (!this.keepCenter)\n        {\n            this.parent.moveCenter(this.options.position as Point);\n        }\n\n        this.parent.emit('animate-end', this.parent);\n\n        if (this.options.callbackOnComplete)\n        {\n            this.options.callbackOnComplete(this.parent);\n        }\n    }\n\n    public update(elapsed: number): void\n    {\n        if (this.paused)\n        {\n            return;\n        }\n        this.time += elapsed;\n\n        if (this.time >= this.options.time)\n        {\n            this.complete();\n        }\n        else\n        {\n            const originalZoom = new Point(this.parent.scale.x, this.parent.scale.y);\n            const percent = this.options.ease(this.time, 0, 1, this.options.time);\n\n            if (this.width !== null)\n            {\n                const startWidth = this.startWidth as number;\n                const deltaWidth = this.deltaWidth as number;\n\n                this.parent.fitWidth(\n                    startWidth + (deltaWidth * percent),\n                    this.keepCenter,\n                    this.height === null);\n            }\n            if (this.height !== null)\n            {\n                const startHeight = this.startHeight as number;\n                const deltaHeight = this.deltaHeight as number;\n\n                this.parent.fitHeight(\n                    startHeight + (deltaHeight * percent),\n                    this.keepCenter,\n                    this.width === null);\n            }\n            if (this.width === null)\n            {\n                this.parent.scale.x = this.parent.scale.y;\n            }\n            else if (this.height === null)\n            {\n                this.parent.scale.y = this.parent.scale.x;\n            }\n            if (!this.keepCenter)\n            {\n                const startX = this.startX as number;\n                const startY = this.startY as number;\n                const deltaX = this.deltaX as number;\n                const deltaY = this.deltaY as number;\n                const original = new Point(this.parent.x, this.parent.y);\n\n                this.parent.moveCenter(startX + (deltaX * percent), startY + (deltaY * percent));\n                this.parent.emit('moved', { viewport: this.parent, original, type: 'animate' });\n            }\n            if (this.width || this.height)\n            {\n                this.parent.emit('zoomed', { viewport: this.parent, original: originalZoom, type: 'animate' });\n            }\n        }\n    }\n}\n","import { Point, Rectangle } from '@pixi/math';\nimport { Plugin } from './Plugin';\nimport ease from '../ease';\n\nimport type { Drag } from './Drag';\nimport type { IDecelerateOptions } from './Decelerate';\nimport type { Pinch } from './Pinch';\nimport type { Viewport } from '../Viewport';\n\n/** Options for {@link Bounce}. */\nexport interface IBounceOptions {\n    /** \"all\", \"horizontal\", \"vertical\", or combination of \"top\", \"bottom\", \"right\", \"left\" (e.g., 'top-bottom-right') */\n    sides?:\n        'all'\n        | 'horizontal'\n        | 'vertical'\n        | string;\n\n    /** Friction to apply to decelerate if active */\n    friction?: number;\n\n    /** Time in ms to finish bounce */\n    time?: number;\n\n    /** Use this bounceBox instead of (0, 0, viewport.worldWidth, viewport.worldHeight) */\n    bounceBox?: Rectangle | null;\n\n    /** Ease function or name (see http://easings.net/ for supported names) */\n    ease?: any;\n\n    /** (top/bottom/center and left/right/center, or center) where to place world if too small for screen */\n    underflow?:  'center' | string;\n}\n\n/** Bounce state along an axis */\nexport interface IBounceState {\n    /** Elapsed time since bounce started */\n    time: number;\n\n    /** Starting coordinate */\n    start: number;\n\n    /** Change in coordinate through bounce */\n    delta: number;\n\n    /** Ending coordinate */\n    end: number;\n}\n\nconst DEFAULT_BOUNCE_OPTIONS: Required<IBounceOptions> = {\n    sides: 'all',\n    friction: 0.5,\n    time: 150,\n    ease: 'easeInOutSine',\n    underflow: 'center',\n    bounceBox: null\n};\n\n/**\n * @fires bounce-start-x\n * @fires bounce.end-x\n * @fires bounce-start-y\n * @fires bounce-end-y\n * @public\n */\nexport class Bounce extends Plugin\n{\n    /** The options passed to initialize this plugin, cannot be modified again. */\n    public readonly options: Readonly<Required<IBounceOptions>>;\n\n    /** Holds whether to bounce from left side. */\n    public readonly left: boolean ;\n\n    /** Holds whether to bounce from top side. */\n    public readonly top: boolean;\n\n    /** Holds whether to bounce from right side. */\n    public readonly right: boolean;\n\n    /** Holds whether to bounce from bottom side. */\n    public readonly bottom: boolean;\n\n    /** Direction of underflow along x-axis. */\n    public readonly underflowX: -1 | 0 | 1;\n\n    /** Direction of underflow along y-axis. */\n    public readonly underflowY: -1 | 0 | 1;\n\n    /** Easing */\n    protected ease: any;\n\n    /** Bounce state along x-axis */\n    protected toX!: IBounceState | null;\n\n    /** Bounce state along y-axis */\n    protected toY!: IBounceState | null;\n\n    /**\n     * This is called by {@link Viewport.bounce}.\n     */\n    constructor(parent: Viewport, options: IBounceOptions = {})\n    {\n        super(parent);\n\n        this.options = Object.assign({}, DEFAULT_BOUNCE_OPTIONS, options);\n        this.ease = ease(this.options.ease, 'easeInOutSine');\n\n        if (this.options.sides)\n        {\n            if (this.options.sides === 'all')\n            {\n                this.top = this.bottom = this.left = this.right = true;\n            }\n            else if (this.options.sides === 'horizontal')\n            {\n                this.right = this.left = true;\n                this.top = this.bottom = false;\n            }\n            else if (this.options.sides === 'vertical')\n            {\n                this.left = this.right = false;\n                this.top = this.bottom = true;\n            }\n            else\n            {\n                this.top = this.options.sides.indexOf('top') !== -1;\n                this.bottom = this.options.sides.indexOf('bottom') !== -1;\n                this.left = this.options.sides.indexOf('left') !== -1;\n                this.right = this.options.sides.indexOf('right') !== -1;\n            }\n        } else {\n            this.left = this.top = this.right = this.bottom = false;\n        }\n\n        const clamp = this.options.underflow.toLowerCase();\n\n        if (clamp === 'center')\n        {\n            this.underflowX = 0;\n            this.underflowY = 0;\n        }\n        else\n        {\n            this.underflowX = (clamp.indexOf('left') !== -1) ? -1 : (clamp.indexOf('right') !== -1) ? 1 : 0;\n            this.underflowY = (clamp.indexOf('top') !== -1) ? -1 : (clamp.indexOf('bottom') !== -1) ? 1 : 0;\n        }\n\n        this.reset();\n    }\n\n    public isActive(): boolean\n    {\n        return this.toX !== null || this.toY !== null;\n    }\n\n    public down(): boolean\n    {\n        this.toX = this.toY = null;\n\n        return false;\n    }\n\n    public up(): boolean\n    {\n        this.bounce();\n\n        return false;\n    }\n\n    public update(elapsed: number): void\n    {\n        if (this.paused)\n        {\n            return;\n        }\n\n        this.bounce();\n\n        if (this.toX)\n        {\n            const toX = this.toX;\n\n            toX.time += elapsed;\n            this.parent.emit('moved', { viewport: this.parent, type: 'bounce-x' });\n\n            if (toX.time >= this.options.time)\n            {\n                this.parent.x = toX.end;\n                this.toX = null;\n                this.parent.emit('bounce-x-end', this.parent);\n            }\n            else\n            {\n                this.parent.x = this.ease(toX.time, toX.start, toX.delta, this.options.time);\n            }\n        }\n\n        if (this.toY)\n        {\n            const toY = this.toY;\n\n            toY.time += elapsed;\n            this.parent.emit('moved', { viewport: this.parent, type: 'bounce-y' });\n\n            if (toY.time >= this.options.time)\n            {\n                this.parent.y = toY.end;\n                this.toY = null;\n                this.parent.emit('bounce-y-end', this.parent);\n            }\n            else\n            {\n                this.parent.y = this.ease(toY.time, toY.start, toY.delta, this.options.time);\n            }\n        }\n    }\n\n    /** @internal */\n    protected calcUnderflowX(): number\n    {\n        let x: number;\n\n        switch (this.underflowX)\n        {\n            case -1:\n                x = 0;\n                break;\n            case 1:\n                x = (this.parent.screenWidth - this.parent.screenWorldWidth);\n                break;\n            default:\n                x = (this.parent.screenWidth - this.parent.screenWorldWidth) / 2;\n        }\n\n        return x;\n    }\n\n    /** @internal */\n    protected calcUnderflowY(): number\n    {\n        let y: number;\n\n        switch (this.underflowY)\n        {\n            case -1:\n                y = 0;\n                break;\n            case 1:\n                y = (this.parent.screenHeight - this.parent.screenWorldHeight);\n                break;\n            default:\n                y = (this.parent.screenHeight - this.parent.screenWorldHeight) / 2;\n        }\n\n        return y;\n    }\n\n    private oob(): Record<'left' | 'right' | 'top' | 'bottom', boolean> & Record<'topLeft' | 'bottomRight', Point>\n    {\n        const box = this.options.bounceBox;\n\n        if (box)\n        {\n            const x1 = typeof box.x === 'undefined' ? 0 : box.x;\n            const y1 = typeof box.y === 'undefined' ? 0 : box.y;\n            const width = typeof box.width === 'undefined' ? this.parent.worldWidth : box.width;\n            const height = typeof box.height === 'undefined' ? this.parent.worldHeight : box.height;\n\n            return {\n                left: this.parent.left < x1,\n                right: this.parent.right > width,\n                top: this.parent.top < y1,\n                bottom: this.parent.bottom > height,\n                topLeft: new Point(\n                    x1 * this.parent.scale.x,\n                    y1 * this.parent.scale.y\n                ),\n                bottomRight: new Point(\n                    width * this.parent.scale.x - this.parent.screenWidth,\n                    height * this.parent.scale.y - this.parent.screenHeight\n                )\n            };\n        }\n\n        return {\n            left: this.parent.left < 0,\n            right: this.parent.right > this.parent.worldWidth,\n            top: this.parent.top < 0,\n            bottom: this.parent.bottom > this.parent.worldHeight,\n            topLeft: new Point(0, 0),\n            bottomRight: new Point(\n                this.parent.worldWidth * this.parent.scale.x - this.parent.screenWidth,\n                this.parent.worldHeight * this.parent.scale.y - this.parent.screenHeight\n            )\n        };\n    }\n\n    public bounce(): void\n    {\n        if (this.paused)\n        {\n            return;\n        }\n\n        let oob;\n        let decelerate: undefined | null | {\n            percentChangeX?: number;\n            percentChangeY?: number;\n            x?: number;\n            y?: number;\n            options?: IDecelerateOptions\n        } = this.parent.plugins.get('decelerate', true) as any;\n\n        if (decelerate && (decelerate.x || decelerate.y))\n        {\n            if ((decelerate.x && decelerate.percentChangeX === decelerate.options?.friction) || (decelerate.y && decelerate.percentChangeY === decelerate.options?.friction))\n            {\n                oob = this.oob();\n                if ((oob.left && this.left) || (oob.right && this.right))\n                {\n                    decelerate.percentChangeX = this.options.friction;\n                }\n                if ((oob.top && this.top) || (oob.bottom && this.bottom))\n                {\n                    decelerate.percentChangeY = this.options.friction;\n                }\n            }\n        }\n        const drag: Partial<Drag> = this.parent.plugins.get('drag', true) || {};\n        const pinch: Partial<Pinch> = this.parent.plugins.get('pinch', true) || {};\n\n        decelerate = decelerate || {};\n\n        if (!drag?.active && !pinch?.active && ((!this.toX || !this.toY) && (!decelerate.x || !decelerate.y)))\n        {\n            oob = oob || this.oob();\n            const topLeft = oob.topLeft;\n            const bottomRight = oob.bottomRight;\n\n            if (!this.toX && !decelerate.x)\n            {\n                let x = null;\n\n                if (oob.left && this.left)\n                {\n                    x = (this.parent.screenWorldWidth < this.parent.screenWidth) ? this.calcUnderflowX() : -topLeft.x;\n                }\n                else if (oob.right && this.right)\n                {\n                    x = (this.parent.screenWorldWidth < this.parent.screenWidth) ? this.calcUnderflowX() : -bottomRight.x;\n                }\n                if (x !== null && this.parent.x !== x)\n                {\n                    this.toX = { time: 0, start: this.parent.x, delta: x - this.parent.x, end: x };\n                    this.parent.emit('bounce-x-start', this.parent);\n                }\n            }\n            if (!this.toY && !decelerate.y)\n            {\n                let y = null;\n\n                if (oob.top && this.top)\n                {\n                    y = (this.parent.screenWorldHeight < this.parent.screenHeight) ? this.calcUnderflowY() : -topLeft.y;\n                }\n                else if (oob.bottom && this.bottom)\n                {\n                    y = (this.parent.screenWorldHeight < this.parent.screenHeight) ? this.calcUnderflowY() : -bottomRight.y;\n                }\n                if (y !== null && this.parent.y !== y)\n                {\n                    this.toY = { time: 0, start: this.parent.y, delta: y - this.parent.y, end: y };\n                    this.parent.emit('bounce-y-start', this.parent);\n                }\n            }\n        }\n    }\n\n    public reset(): void\n    {\n        this.toX = this.toY = null;\n        this.bounce();\n    }\n}\n","import { Plugin } from './Plugin';\n\nimport type { Viewport } from '../Viewport';\n\n/**\n * There are three ways to clamp:\n * 1. direction: 'all' = the world is clamped to its world boundaries, ie, you cannot drag any part of the world offscreen\n *    direction: 'x' | 'y' = only the x or y direction is clamped to its world boundary\n * 2. left, right, top, bottom = true | number = the world is clamped to the world's pixel location for each side;\n *    if any of these are set to true, then the location is set to the boundary [0, viewport.worldWidth/viewport.worldHeight]\n *    eg: to allow the world to be completely dragged offscreen, set [-viewport.worldWidth, -viewport.worldHeight, viewport.worldWidth * 2, viewport.worldHeight * 2]\n *\n * Underflow determines what happens when the world is smaller than the viewport\n * 1. none = the world is clamped but there is no special behavior\n * 2. center = the world is centered on the viewport\n * 3. combination of top/bottom/center and left/right/center (case insensitive) = the world is stuck to the appropriate boundaries\n *\n */\nexport interface IClampOptions\n{\n   /**\n    * Clamp left; true = 0\n    *\n    * @default false\n    */\n    left?: number | boolean | null;\n\n   /**\n    * Clamp top; true = 0\n    *\n    * @default false\n    */\n    top?: number | boolean | null;\n\n    /**\n     * Clamp right; true = viewport.worldWidth\n     *\n     * @default false\n     */\n    right?: number | boolean | null;\n\n    /**\n     * Clamp bottom; true = viewport.worldHeight\n     *\n     * @default false\n     */\n    bottom?: number | boolean | null;\n\n    /**\n     * (all, x, or y) using clamps of [0, viewport.worldWidth/viewport.worldHeight]; replaces left/right/top/bottom if set\n     *\n     * @default null\n     */\n    direction?: 'all' | 'x' | 'y' | null;\n\n    /**\n     * Where to place world if too small for screen (e.g., top-right, center, none, bottomleft)\n     *\n     * @default 'center'\n     */\n    underflow?: 'center' | string;\n}\n\nconst DEFAULT_CLAMP_OPTIONS: Required<IClampOptions> = {\n    left: false,\n    right: false,\n    top: false,\n    bottom: false,\n    direction: null,\n    underflow: 'center'\n};\n\n/**\n * Plugin to clamp the viewport to a specific world bounding box.\n *\n * @public\n */\nexport class Clamp extends Plugin\n{\n    /** Options used to initialize this plugin, cannot be modified later. */\n    public readonly options: Required<IClampOptions>;\n\n    /** Last state of viewport */\n    protected last: {\n        x: number | null;\n        y: number | null;\n        scaleX: number | null;\n        scaleY: number | null;\n    };\n\n    protected noUnderflow!: boolean;\n    protected underflowX!: -1 | 0 | 1;\n    protected underflowY!: -1 | 0 | 1;\n\n    /**\n     * This is called by {@link Viewport.clamp}.\n     */\n    constructor(parent: Viewport, options : IClampOptions = {})\n    {\n        super(parent);\n        this.options = Object.assign({}, DEFAULT_CLAMP_OPTIONS, options);\n\n        if (this.options.direction)\n        {\n            this.options.left = this.options.direction === 'x' || this.options.direction === 'all' ? true : null;\n            this.options.right = this.options.direction === 'x' || this.options.direction === 'all' ? true : null;\n            this.options.top = this.options.direction === 'y' || this.options.direction === 'all' ? true : null;\n            this.options.bottom = this.options.direction === 'y' || this.options.direction === 'all' ? true : null;\n        }\n\n        this.parseUnderflow();\n        this.last = { x: null, y: null, scaleX: null, scaleY: null };\n        this.update();\n    }\n\n    private parseUnderflow()\n    {\n        const clamp = this.options.underflow.toLowerCase();\n\n        if (clamp === 'none')\n        {\n            this.noUnderflow = true;\n        }\n        else if (clamp === 'center')\n        {\n            this.underflowX = this.underflowY = 0;\n            this.noUnderflow = false;\n        }\n        else\n        {\n            this.underflowX = (clamp.indexOf('left') !== -1) ? -1 : (clamp.indexOf('right') !== -1) ? 1 : 0;\n            this.underflowY = (clamp.indexOf('top') !== -1) ? -1 : (clamp.indexOf('bottom') !== -1) ? 1 : 0;\n            this.noUnderflow = false;\n        }\n    }\n\n    public move(): boolean\n    {\n        this.update();\n\n        return false;\n    }\n\n    public update(): void\n    {\n        if (this.paused)\n        {\n            return;\n        }\n\n        // only clamp on change\n        if (this.parent.x === this.last.x\n            && this.parent.y === this.last.y\n            && this.parent.scale.x === this.last.scaleX\n            && this.parent.scale.y === this.last.scaleY)\n        {\n            return;\n        }\n        const original = { x: this.parent.x, y: this.parent.y };\n        // TODO: Fix\n        const decelerate: any = (this.parent.plugins as any).decelerate || {};\n\n        if (this.options.left !== null || this.options.right !== null)\n        {\n            let moved = false;\n\n            if (!this.noUnderflow && this.parent.screenWorldWidth < this.parent.screenWidth)\n            {\n                switch (this.underflowX)\n                {\n                    case -1:\n                        if (this.parent.x !== 0)\n                        {\n                            this.parent.x = 0;\n                            moved = true;\n                        }\n                        break;\n                    case 1:\n                        if (this.parent.x !== this.parent.screenWidth - this.parent.screenWorldWidth)\n                        {\n                            this.parent.x = this.parent.screenWidth - this.parent.screenWorldWidth;\n                            moved = true;\n                        }\n                        break;\n                    default:\n                        if (this.parent.x !== (this.parent.screenWidth - this.parent.screenWorldWidth) / 2)\n                        {\n                            this.parent.x = (this.parent.screenWidth - this.parent.screenWorldWidth) / 2;\n                            moved = true;\n                        }\n                }\n            }\n            else\n            {\n                if (this.options.left !== null)\n                {\n                    if (this.parent.left < (this.options.left === true ? 0 : this.options.left))\n                    {\n                        this.parent.x = -(this.options.left === true ? 0 : this.options.left) * this.parent.scale.x;\n                        decelerate.x = 0;\n                        moved = true;\n                    }\n                }\n                if (this.options.right !== null)\n                {\n                    if (this.parent.right > (this.options.right === true ? this.parent.worldWidth : this.options.right))\n                    {\n                        this.parent.x = -(this.options.right === true ? this.parent.worldWidth : this.options.right) * this.parent.scale.x + this.parent.screenWidth;\n                        decelerate.x = 0;\n                        moved = true;\n                    }\n                }\n            }\n            if (moved)\n            {\n                this.parent.emit('moved', { viewport: this.parent, original, type: 'clamp-x' });\n            }\n        }\n        if (this.options.top !== null || this.options.bottom !== null)\n        {\n            let moved = false;\n\n            if (!this.noUnderflow && this.parent.screenWorldHeight < this.parent.screenHeight)\n            {\n                switch (this.underflowY)\n                {\n                    case -1:\n                        if (this.parent.y !== 0)\n                        {\n                            this.parent.y = 0;\n                            moved = true;\n                        }\n                        break;\n                    case 1:\n                        if (this.parent.y !== this.parent.screenHeight - this.parent.screenWorldHeight)\n                        {\n                            this.parent.y = (this.parent.screenHeight - this.parent.screenWorldHeight);\n                            moved = true;\n                        }\n                        break;\n                    default:\n                        if (this.parent.y !== (this.parent.screenHeight - this.parent.screenWorldHeight) / 2)\n                        {\n                            this.parent.y = (this.parent.screenHeight - this.parent.screenWorldHeight) / 2;\n                            moved = true;\n                        }\n                }\n            }\n            else\n            {\n                if (this.options.top !== null)\n                {\n                    if (this.parent.top < (this.options.top === true ? 0 : this.options.top))\n                    {\n                        this.parent.y = -(this.options.top === true ? 0 : this.options.top)\n                            * this.parent.scale.y;\n                        decelerate.y = 0;\n                        moved = true;\n                    }\n                }\n                if (this.options.bottom !== null)\n                {\n                    if (this.parent.bottom > (this.options.bottom === true ? this.parent.worldHeight : this.options.bottom))\n                    {\n                        this.parent.y = -(this.options.bottom === true ? this.parent.worldHeight : this.options.bottom)\n                            * this.parent.scale.y + this.parent.screenHeight;\n                        decelerate.y = 0;\n                        moved = true;\n                    }\n                }\n            }\n            if (moved)\n            {\n                this.parent.emit('moved', { viewport: this.parent, original, type: 'clamp-y' });\n            }\n        }\n        this.last.x = this.parent.x;\n        this.last.y = this.parent.y;\n        this.last.scaleX = this.parent.scale.x;\n        this.last.scaleY = this.parent.scale.y;\n    }\n\n    public reset(): void\n    {\n        this.update();\n    }\n}\n","import { Plugin } from './Plugin';\n\nimport type { Viewport } from '../Viewport';\n\n/**\n * Options for {@link ClampZoom}.\n *\n * Use either minimum width/height or minimum scale\n */\nexport interface IClampZoomOptions\n{\n    /** Minimum width */\n    minWidth?: number | null;\n\n    /** Minimum height */\n    minHeight?: number | null;\n\n    /** Maximum width */\n    maxWidth?: number | null;\n\n    /** Maximum height */\n    maxHeight?: number | null;\n\n    /** Minimum scale */\n    minScale?: number | null | IScale;\n\n    /** Maximum scale */\n    maxScale?: number | null | IScale;\n}\n\nconst DEFAULT_CLAMP_ZOOM_OPTIONS: Required<IClampZoomOptions> = {\n    minWidth: null,\n    minHeight: null,\n    maxWidth: null,\n    maxHeight: null,\n    minScale: null,\n    maxScale: null\n};\n\n/**\n * Plugin to clamp the viewport's zoom to a specific range.\n *\n * @public\n */\nexport class ClampZoom extends Plugin\n{\n    public readonly options: Required<IClampZoomOptions>;\n\n    /**\n     * This is called by {@link Viewport.clampZoom}.\n     */\n    constructor(parent: Viewport, options = {})\n    {\n        super(parent);\n        this.options = Object.assign({}, DEFAULT_CLAMP_ZOOM_OPTIONS, options);\n\n        this.clamp();\n    }\n\n    public resize(): void\n    {\n        this.clamp();\n    }\n\n    /** Clamp the viewport scale zoom) */\n    public clamp(): void\n    {\n        if (this.paused)\n        {\n            return;\n        }\n\n        if (this.options.minWidth || this.options.minHeight || this.options.maxWidth || this.options.maxHeight)\n        {\n            let width = this.parent.worldScreenWidth;\n            let height = this.parent.worldScreenHeight;\n\n            if (this.options.minWidth !== null && width < this.options.minWidth)\n            {\n                const original = this.parent.scale.x;\n\n                this.parent.fitWidth(this.options.minWidth, false, false, true);\n                this.parent.scale.y *= this.parent.scale.x / original;\n                width = this.parent.worldScreenWidth;\n                height = this.parent.worldScreenHeight;\n                this.parent.emit('zoomed', { viewport: this.parent, type: 'clamp-zoom' });\n            }\n            if (this.options.maxWidth !== null && width > this.options.maxWidth)\n            {\n                const original = this.parent.scale.x;\n\n                this.parent.fitWidth(this.options.maxWidth, false, false, true);\n                this.parent.scale.y *= this.parent.scale.x / original;\n                width = this.parent.worldScreenWidth;\n                height = this.parent.worldScreenHeight;\n                this.parent.emit('zoomed', { viewport: this.parent, type: 'clamp-zoom' });\n            }\n            if (this.options.minHeight !== null && height < this.options.minHeight)\n            {\n                const original = this.parent.scale.y;\n\n                this.parent.fitHeight(this.options.minHeight, false, false, true);\n                this.parent.scale.x *= this.parent.scale.y / original;\n                width = this.parent.worldScreenWidth;\n                height = this.parent.worldScreenHeight;\n                this.parent.emit('zoomed', { viewport: this.parent, type: 'clamp-zoom' });\n            }\n            if (this.options.maxHeight !== null && height > this.options.maxHeight)\n            {\n                const original = this.parent.scale.y;\n\n                this.parent.fitHeight(this.options.maxHeight, false, false, true);\n                this.parent.scale.x *= this.parent.scale.y / original;\n                this.parent.emit('zoomed', { viewport: this.parent, type: 'clamp-zoom' });\n            }\n        }\n        else\n        if (this.options.minScale || this.options.maxScale)\n        {\n            const minScale: IScale = { x: null, y: null };\n            const maxScale: IScale = { x: null, y: null };\n\n            if (typeof this.options.minScale === 'number')\n            {\n                minScale.x = this.options.minScale;\n                minScale.y = this.options.minScale;\n            }\n            else if (this.options.minScale !== null)\n            {\n                const optsMinScale = this.options.minScale as IScale;\n\n                minScale.x = typeof optsMinScale.x === 'undefined' ? null : optsMinScale.x;\n                minScale.y = typeof optsMinScale.y === 'undefined' ? null : optsMinScale.y;\n            }\n\n            if (typeof this.options.maxScale === 'number')\n            {\n                maxScale.x = this.options.maxScale;\n                maxScale.y = this.options.maxScale;\n            }\n            else if (this.options.maxScale !== null)\n            {\n                const optsMaxScale = this.options.maxScale as IScale;\n\n                maxScale.x = typeof optsMaxScale.x === 'undefined' ? null : optsMaxScale.x;\n                maxScale.y = typeof optsMaxScale.y === 'undefined' ? null : optsMaxScale.y;\n            }\n\n            let scaleX = this.parent.scale.x;\n            let scaleY = this.parent.scale.y;\n\n            if (minScale.x !== null && scaleX < minScale.x)\n            {\n                scaleX = minScale.x;\n            }\n            if (maxScale.x !== null && scaleX > maxScale.x)\n            {\n                scaleX = maxScale.x;\n            }\n            if (minScale.y !== null && scaleY < minScale.y)\n            {\n                scaleY = minScale.y;\n            }\n            if (maxScale.y !== null && scaleY > maxScale.y)\n            {\n                scaleY = maxScale.y;\n            }\n            if (scaleX !== this.parent.scale.x || scaleY !== this.parent.scale.y)\n            {\n                this.parent.scale.set(scaleX, scaleY);\n                this.parent.emit('zoomed', { viewport: this.parent, type: 'clamp-zoom' });\n            }\n        }\n    }\n\n    public reset(): void\n    {\n        this.clamp();\n    }\n}\n\n/** This allows independent x and y values for min/maxScale */\nexport interface IScale {\n    x: null | number\n    y: null | number\n}\n","import { Plugin } from './Plugin';\n\nimport type { Point } from '@pixi/math';\nimport type { Viewport } from '../Viewport';\n\nexport interface IDecelerateOptions {\n    /**\n     * Percent to decelerate after movement. This should be between 0 and 1, exclusive.\n     *\n     * @default 0.95\n     */\n    friction?: number;\n\n    /**\n     * Percent to decelerate when past boundaries (only applicable when viewport.bounce() is active)\n     *\n     * @default 0.8\n     */\n    bounce?: number;\n\n    /**\n     * Minimum velocity before stopping/reversing acceleration\n     *\n     * @default 0.01\n     */\n    minSpeed?: number;\n}\n\n/** Viewport position snapshot that's saved by {@link DeceleratePlugin} to estimate panning velocity. */\nexport interface IDecelerateSnapshot {\n    /** x-coordinate of the viewport. */\n    x: number;\n\n    /** y-coordinate of the viewport. */\n    y: number;\n\n    /** Time at which this snapshot was taken. */\n    time: number;\n}\n\nconst DEFAULT_DECELERATE_OPTIONS: Required<IDecelerateOptions> = {\n    friction: 0.98,\n    bounce: 0.8,\n    minSpeed: 0.01\n};\n\n/**\n * Time period of decay (1 frame)\n *\n * @internal\n * @ignore\n */\nconst TP = 16;\n\n/**\n * Plugin to decelerate viewport velocity smoothly after panning ends.\n *\n * @public\n */\nexport class Decelerate extends Plugin\n{\n    /** Options used to initialize this plugin. */\n    public readonly options: Required<IDecelerateOptions>;\n\n    /**\n     * x-component of the velocity of viewport provided by this plugin, at the current time.\n     *\n     * This is measured in px/frame, where a frame is normalized to 16 milliseconds.\n     */\n    public x!: number | null;\n\n    /**\n     * y-component of the velocity of the viewport provided by this plugin, at the current time.\n     *\n     * This is measured in px/frame, where a frame is normalized to 16 milliseconds.\n     */\n    public y!: number | null;\n\n    /**\n     * The decay factor for the x-component of the viewport.\n     *\n     * The viewport's velocity decreased by this amount each 16 milliseconds.\n     */\n    public percentChangeX!: number;\n\n    /**\n     * The decay factor for the y-component of the viewport.\n     *\n     * The viewport's velocity decreased by this amount each 16 milliseconds.\n     */\n    public percentChangeY!: number;\n\n    /** Saved list of recent viewport position snapshots, to estimate velocity. */\n    protected saved: Array<IDecelerateSnapshot>;\n\n    /** The time since the user released panning of the viewport. */\n    protected timeSinceRelease: number;\n\n    /**\n     * This is called by {@link Viewport.decelerate}.\n     */\n    constructor(parent: Viewport, options: IDecelerateOptions = {})\n    {\n        super(parent);\n\n        this.options = Object.assign({}, DEFAULT_DECELERATE_OPTIONS, options);\n        this.saved = [];\n        this.timeSinceRelease = 0;\n\n        this.reset();\n        this.parent.on('moved', (data) => this.moved(data));\n    }\n\n    public down(): boolean\n    {\n        this.saved = [];\n        this.x = this.y = null;\n\n        return false;\n    }\n\n    public isActive(): boolean\n    {\n        return !!(this.x || this.y);\n    }\n\n    public move(): boolean\n    {\n        if (this.paused)\n        {\n            return false;\n        }\n\n        const count = this.parent.input.count();\n\n        if (count === 1 || (count > 1 && !this.parent.plugins.get('pinch', true)))\n        {\n            this.saved.push({ x: this.parent.x, y: this.parent.y, time: performance.now() });\n\n            if (this.saved.length > 60)\n            {\n                this.saved.splice(0, 30);\n            }\n        }\n\n        // Silently recording viewport positions\n        return false;\n    }\n\n    /** Listener to viewport's \"moved\" event. */\n    protected moved(data: { type: 'clamp-x' | 'clamp-y'; original: Point }): void\n    {\n        if (this.saved.length)\n        {\n            const last = this.saved[this.saved.length - 1];\n\n            if (data.type === 'clamp-x')\n            {\n                if (last.x === data.original.x)\n                {\n                    last.x = this.parent.x;\n                }\n            }\n            else if (data.type === 'clamp-y')\n            {\n                if (last.y === data.original.y)\n                {\n                    last.y = this.parent.y;\n                }\n            }\n        }\n    }\n\n    public up(): boolean\n    {\n        if (this.parent.input.count() === 0 && this.saved.length)\n        {\n            const now = performance.now();\n\n            for (const save of this.saved)\n            {\n                if (save.time >= now - 100)\n                {\n                    const time = now - save.time;\n\n                    this.x = (this.parent.x - save.x) / time;\n                    this.y = (this.parent.y - save.y) / time;\n                    this.percentChangeX = this.percentChangeY = this.options.friction;\n                    this.timeSinceRelease = 0;\n                    break;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Manually activate deceleration, starting from the (x, y) velocity components passed in the options.\n     *\n     * @param {object} options\n     * @param {number} [options.x] - Specify x-component of initial velocity.\n     * @param {number} [options.y] - Specify y-component of initial velocity.\n     */\n    public activate(options: { x?: number; y?: number; }): void\n    {\n        options = options || {};\n\n        if (typeof options.x !== 'undefined')\n        {\n            this.x = options.x;\n            this.percentChangeX = this.options.friction;\n        }\n        if (typeof options.y !== 'undefined')\n        {\n            this.y = options.y;\n            this.percentChangeY = this.options.friction;\n        }\n    }\n\n    public update(elapsed: number): void\n    {\n        if (this.paused)\n        {\n            return;\n        }\n\n        /*\n         * See https://github.com/davidfig/pixi-viewport/issues/271 for math.\n         *\n         * The viewport velocity (this.x, this.y) decays exponentially by the the decay factor\n         * (this.percentChangeX, this.percentChangeY) each frame. This velocity function is integrated\n         * to calculate the displacement.\n         */\n\n        const moved = this.x || this.y;\n\n        const ti = this.timeSinceRelease;\n        const tf = this.timeSinceRelease + elapsed;\n\n        if (this.x)\n        {\n            const k = this.percentChangeX;\n            const lnk = Math.log(k);\n\n            // Apply velocity delta on the viewport x-coordinate.\n            this.parent.x += ((this.x * TP) / lnk) * (Math.pow(k, tf / TP) - Math.pow(k, ti / TP));\n\n            // Apply decay on x-component of velocity\n            this.x *= Math.pow(this.percentChangeX, elapsed / TP);\n        }\n        if (this.y)\n        {\n            const k = this.percentChangeY;\n            const lnk = Math.log(k);\n\n            // Apply velocity delta on the viewport y-coordinate.\n            this.parent.y += ((this.y * TP) / lnk) * (Math.pow(k, tf / TP) - Math.pow(k, ti / TP));\n\n            // Apply decay on y-component of velocity\n            this.y *= Math.pow(this.percentChangeY, elapsed / TP);\n        }\n\n        this.timeSinceRelease += elapsed;\n\n        // End decelerate velocity once it goes under a certain amount of precision.\n        if (this.x && this.y) {\n            if (Math.abs(this.x) < this.options.minSpeed && Math.abs(this.y) < this.options.minSpeed) {\n                 this.x = 0;\n                 this.y = 0;\n            }\n        } else {\n            if (Math.abs(this.x || 0) < this.options.minSpeed) {\n                this.x = 0;\n            }\n            if (Math.abs(this.y || 0) < this.options.minSpeed) {\n                this.y = 0;\n            }\n        }\n\n        if (moved)\n        {\n            this.parent.emit('moved', { viewport: this.parent, type: 'decelerate' });\n        }\n    }\n\n    public reset(): void\n    {\n        this.x = this.y = null;\n    }\n}\n","import { Point } from '@pixi/math';\nimport { Plugin } from './Plugin';\n\nimport type { Decelerate } from './Decelerate';\nimport type { InteractionEvent } from '@pixi/interaction';\nimport type { IPointData } from '@pixi/math';\nimport type { Viewport } from '../Viewport';\n\n/** Options for {@link Drag}. */\nexport interface IDragOptions {\n    /**\n     * direction to drag\n     *\n     * @default \"all\"\n     */\n    direction?: string;\n\n    /**\n     * whether click to drag is active\n     *\n     * @default true\n     */\n    pressDrag?: boolean;\n\n    /**\n     * Use wheel to scroll in direction (unless wheel plugin is active)\n     *\n     * @default true\n     */\n    wheel?: boolean;\n\n    /**\n     * number of pixels to scroll with each wheel spin\n     *\n     * @default 1\n     */\n    wheelScroll?: number;\n\n    /**\n     * reverse the direction of the wheel scroll\n     *\n     * @default false\n     */\n    reverse?: boolean;\n\n    /**\n     * clamp wheel(to avoid weird bounce with mouse wheel). Can be 'x' or 'y' or `true`.\n     *\n     * @default false\n     */\n    clampWheel?: boolean | string;\n\n    /**\n     * where to place world if too small for screen\n     *\n     * @default \"center\"\n     */\n    underflow?: string;\n\n    /**\n     * factor to multiply drag to increase the speed of movement\n     *\n     * @default 1\n     */\n    factor?: number;\n\n    /**\n     * Changes which mouse buttons trigger drag.\n     *\n     * Use: 'all', 'left', right' 'middle', or some combination, like, 'middle-right'; you may want to set\n     * `viewport.options.disableOnContextMenu` if you want to use right-click dragging.\n     *\n     * @default \"all\"\n     */\n    mouseButtons?: 'all' | string;\n\n    /**\n     * Array containing {@link key|https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code} codes of\n     * keys that can be pressed for the drag to be triggered, e.g.: ['ShiftLeft', 'ShiftRight'}.\n     *\n     * @default null\n     */\n    keyToPress?: string[] | null;\n\n    /**\n     * Ignore keyToPress for touch events.\n     *\n     * @default false\n     */\n    ignoreKeyToPressOnTouch?: boolean;\n\n    /**\n     * Scaling factor for non-DOM_DELTA_PIXEL scrolling events.\n     *\n     * @default 20\n     */\n    lineHeight?: number;\n}\n\nconst DEFAULT_DRAG_OPTIONS: Required<IDragOptions> = {\n    direction: 'all',\n    pressDrag: true,\n    wheel: true,\n    wheelScroll: 1,\n    reverse: false,\n    clampWheel: false,\n    underflow: 'center',\n    factor: 1,\n    mouseButtons: 'all',\n    keyToPress: null,\n    ignoreKeyToPressOnTouch: false,\n    lineHeight: 20,\n};\n\n/**\n * Plugin to enable panning/dragging of the viewport to move around.\n *\n * @public\n */\nexport class Drag extends Plugin\n{\n    /** Options used to initialize this plugin, cannot be modified later. */\n    public readonly options: Readonly<Required<IDragOptions>>;\n\n    /** Flags when viewport is moving. */\n    protected moved: boolean;\n\n    /** Factor to apply from {@link IDecelerateOptions}'s reverse. */\n    protected reverse: 1 | -1;\n\n    /** Holds whether dragging is enabled along the x-axis. */\n    protected xDirection: boolean;\n\n    /** Holds whether dragging is enabled along the y-axis. */\n    protected yDirection: boolean;\n\n    /** Flags whether the keys required to drag are pressed currently. */\n    protected keyIsPressed: boolean;\n\n    /** Holds whether the left, center, and right buttons are required to pan. */\n    protected mouse!: [boolean, boolean, boolean];\n\n    /** Underflow factor along x-axis */\n    protected underflowX!: -1 | 0 | 1;\n\n    /** Underflow factor along y-axis */\n    protected underflowY!: -1 | 0 | 1;\n\n    /** Last pointer position while panning. */\n    protected last?: IPointData | null;\n\n    /** The ID of the pointer currently panning the viewport. */\n    protected current?: number;\n\n    /**\n     * This is called by {@link Viewport.drag}.\n     */\n    constructor(parent: Viewport, options = {})\n    {\n        super(parent);\n\n        this.options = Object.assign({}, DEFAULT_DRAG_OPTIONS, options);\n        this.moved = false;\n        this.reverse = this.options.reverse ? 1 : -1;\n        this.xDirection = !this.options.direction || this.options.direction === 'all' || this.options.direction === 'x';\n        this.yDirection = !this.options.direction || this.options.direction === 'all' || this.options.direction === 'y';\n        this.keyIsPressed = false;\n\n        this.parseUnderflow();\n        this.mouseButtons(this.options.mouseButtons);\n\n        if (this.options.keyToPress)\n        {\n            this.handleKeyPresses(this.options.keyToPress);\n        }\n    }\n\n    /**\n     * Handles keypress events and set the keyIsPressed boolean accordingly\n     *\n     * @param {array} codes - key codes that can be used to trigger drag event\n     */\n    protected handleKeyPresses(codes: string[]): void\n    {\n        window.addEventListener('keydown', (e) =>\n        {\n            if (codes.includes(e.code))\n            { this.keyIsPressed = true; }\n        });\n\n        window.addEventListener('keyup', (e) =>\n        {\n            if (codes.includes(e.code))\n            { this.keyIsPressed = false; }\n        });\n    }\n\n    /**\n     * initialize mousebuttons array\n     * @param {string} buttons\n     */\n    protected mouseButtons(buttons: string): void\n    {\n        if (!buttons || buttons === 'all')\n        {\n            this.mouse = [true, true, true];\n        }\n        else\n        {\n            this.mouse = [\n                buttons.indexOf('left') !== -1,\n                buttons.indexOf('middle') !== -1,\n                buttons.indexOf('right') !== -1\n            ];\n        }\n    }\n\n    protected parseUnderflow(): void\n    {\n        const clamp = this.options.underflow.toLowerCase();\n\n        if (clamp === 'center')\n        {\n            this.underflowX = 0;\n            this.underflowY = 0;\n        }\n        else\n        {\n            if (clamp.includes('left'))\n            {\n                this.underflowX = -1;\n            }\n            else if (clamp.includes('right'))\n            {\n                this.underflowX = 1;\n            }\n            else\n            {\n                this.underflowX = 0;\n            }\n            if (clamp.includes('top'))\n            {\n                this.underflowY = -1;\n            }\n            else if (clamp.includes('bottom'))\n            {\n                this.underflowY = 1;\n            }\n            else\n            {\n                this.underflowY = 0;\n            }\n        }\n    }\n\n    /**\n     * @param {PIXI.InteractionEvent} event\n     * @returns {boolean}\n     */\n    protected checkButtons(event: InteractionEvent): boolean\n    {\n        const isMouse = event.data.pointerType === 'mouse';\n        const count = this.parent.input.count();\n\n        if ((count === 1) || (count > 1 && !this.parent.plugins.get('pinch', true)))\n        {\n            if (!isMouse || this.mouse[event.data.button])\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * @param {PIXI.InteractionEvent} event\n     * @returns {boolean}\n     */\n    protected checkKeyPress(event: InteractionEvent): boolean\n    {\n        return (!this.options.keyToPress\n            || this.keyIsPressed\n            || (this.options.ignoreKeyToPressOnTouch && event.data.pointerType === 'touch'));\n    }\n\n    public down(event: InteractionEvent): boolean\n    {\n        if (this.paused || !this.options.pressDrag)\n        {\n            return false;\n        }\n        if (this.checkButtons(event) && this.checkKeyPress(event))\n        {\n            this.last = { x: event.data.global.x, y: event.data.global.y };\n            this.current = event.data.pointerId;\n\n            return true;\n        }\n        this.last = null;\n\n        return false;\n    }\n\n    get active(): boolean\n    {\n        return this.moved;\n    }\n\n    public move(event: InteractionEvent): boolean\n    {\n        if (this.paused || !this.options.pressDrag)\n        {\n            return false;\n        }\n        if (this.last && this.current === event.data.pointerId)\n        {\n            const x = event.data.global.x;\n            const y = event.data.global.y;\n            const count = this.parent.input.count();\n\n            if (count === 1 || (count > 1 && !this.parent.plugins.get('pinch', true)))\n            {\n                const distX = x - this.last.x;\n                const distY = y - this.last.y;\n\n                if (this.moved\n                    || ((this.xDirection && this.parent.input.checkThreshold(distX))\n                    || (this.yDirection && this.parent.input.checkThreshold(distY))))\n                {\n                    const newPoint = { x, y };\n\n                    if (this.xDirection)\n                    {\n                        this.parent.x += (newPoint.x - this.last.x) * this.options.factor;\n                    }\n                    if (this.yDirection)\n                    {\n                        this.parent.y += (newPoint.y - this.last.y) * this.options.factor;\n                    }\n                    this.last = newPoint;\n                    if (!this.moved)\n                    {\n                        this.parent.emit('drag-start', {\n                            event,\n                            screen: new Point(this.last.x, this.last.y),\n                            world: this.parent.toWorld(new Point(this.last.x, this.last.y)),\n                            viewport: this.parent\n                        });\n                    }\n                    this.moved = true;\n                    this.parent.emit('moved', { viewport: this.parent, type: 'drag' });\n\n                    return true;\n                }\n            }\n            else\n            {\n                this.moved = false;\n            }\n        }\n\n        return false;\n    }\n\n    public up(event: InteractionEvent): boolean\n    {\n        if (this.paused)\n        {\n            return false;\n        }\n\n        const touches = this.parent.input.touches;\n\n        if (touches.length === 1)\n        {\n            const pointer = touches[0];\n\n            if (pointer.last)\n            {\n                this.last = { x: pointer.last.x, y: pointer.last.y };\n                this.current = pointer.id;\n            }\n            this.moved = false;\n\n            return true;\n        }\n        else if (this.last)\n        {\n            if (this.moved)\n            {\n                const screen = new Point(this.last.x, this.last.y);\n\n                this.parent.emit('drag-end', {\n                    event, screen,\n                    world: this.parent.toWorld(screen),\n                    viewport: this.parent,\n                });\n                this.last = null;\n                this.moved = false;\n\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public wheel(event: WheelEvent): boolean\n    {\n        if (this.paused)\n        {\n            return false;\n        }\n\n        if (this.options.wheel)\n        {\n            const wheel = this.parent.plugins.get('wheel', true);\n\n            if (!wheel || (!wheel.options.wheelZoom && !event.ctrlKey))\n            {\n                const step = event.deltaMode ? this.options.lineHeight : 1;\n\n                if (this.xDirection)\n                {\n                    this.parent.x += event.deltaX * step * this.options.wheelScroll * this.reverse;\n                }\n                if (this.yDirection)\n                {\n                    this.parent.y += event.deltaY * step * this.options.wheelScroll * this.reverse;\n                }\n                if (this.options.clampWheel)\n                {\n                    this.clamp();\n                }\n                this.parent.emit('wheel-scroll', this.parent);\n                this.parent.emit('moved', { viewport: this.parent, type: 'wheel' });\n                if (!this.parent.options.passiveWheel)\n                {\n                    event.preventDefault();\n                }\n                if (this.parent.options.stopPropagation)\n                {\n                    event.stopPropagation();\n                }\n\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public resume(): void\n    {\n        this.last = null;\n        this.paused = false;\n    }\n\n    public clamp(): void\n    {\n        const decelerate: Partial<Decelerate> = this.parent.plugins.get('decelerate', true) || {};\n\n        if (this.options.clampWheel !== 'y')\n        {\n            if (this.parent.screenWorldWidth < this.parent.screenWidth)\n            {\n                switch (this.underflowX)\n                {\n                    case -1:\n                        this.parent.x = 0;\n                        break;\n                    case 1:\n                        this.parent.x = (this.parent.screenWidth - this.parent.screenWorldWidth);\n                        break;\n                    default:\n                        this.parent.x = (this.parent.screenWidth - this.parent.screenWorldWidth) / 2;\n                }\n            }\n            else\n            if (this.parent.left < 0)\n            {\n                this.parent.x = 0;\n                decelerate.x = 0;\n            }\n            else if (this.parent.right > this.parent.worldWidth)\n            {\n                this.parent.x = (-this.parent.worldWidth * this.parent.scale.x) + this.parent.screenWidth;\n                decelerate.x = 0;\n            }\n        }\n        if (this.options.clampWheel !== 'x')\n        {\n            if (this.parent.screenWorldHeight < this.parent.screenHeight)\n            {\n                switch (this.underflowY)\n                {\n                    case -1:\n                        this.parent.y = 0;\n                        break;\n                    case 1:\n                        this.parent.y = (this.parent.screenHeight - this.parent.screenWorldHeight);\n                        break;\n                    default:\n                        this.parent.y = (this.parent.screenHeight - this.parent.screenWorldHeight) / 2;\n                }\n            }\n            else\n            {\n                if (this.parent.top < 0)\n                {\n                    this.parent.y = 0;\n                    decelerate.y = 0;\n                }\n                if (this.parent.bottom > this.parent.worldHeight)\n                {\n                    this.parent.y = (-this.parent.worldHeight * this.parent.scale.y) + this.parent.screenHeight;\n                    decelerate.y = 0;\n                }\n            }\n        }\n    }\n}\n","import { Plugin } from './Plugin';\n\nimport type { DisplayObject } from '@pixi/display';\nimport type { IPointData } from '@pixi/math';\nimport type { Viewport } from '../Viewport';\n\n/** Options for {@link Follow}. */\nexport interface IFollowOptions\n{\n    /**\n     * Speed to follow in px/frame (0 = teleport to location)\n     *\n     * @default 9\n     */\n    speed?: number;\n\n    /**\n     * Set acceleration to accelerate and decelerate at this rate; speed cannot be 0 to use acceleration\n     *\n     * @default null\n     */\n    acceleration?: number | null;\n\n    /**\n     * Radius (in world coordinates) of center circle where movement is allowed without moving the viewport\n     *\n     * @default null\n     */\n    radius?: number | null;\n}\n\nconst DEFAULT_FOLLOW_OPTIONS: Required<IFollowOptions> = {\n    speed: 0,\n    acceleration: null,\n    radius: null\n};\n\n/**\n * Plugin to follow a display-object.\n *\n * @see Viewport.follow\n * @public\n */\nexport class Follow extends Plugin\n{\n    /** The options used to initialize this plugin. */\n    public readonly options: Required<IFollowOptions>;\n\n    /** The target this plugin will make the viewport follow. */\n    public target: DisplayObject;\n\n    /** The velocity provided the viewport by following, at the current time. */\n    protected velocity: IPointData;\n\n    /**\n     * This is called by {@link Viewport.follow}.\n     *\n     * @param parent\n     * @param target - target to follow\n     * @param options\n     */\n    constructor(parent: Viewport, target: DisplayObject, options: IFollowOptions = {})\n    {\n        super(parent);\n\n        this.target = target;\n        this.options = Object.assign({}, DEFAULT_FOLLOW_OPTIONS, options);\n        this.velocity = { x: 0, y: 0 };\n    }\n\n    public update(elapsed: number): void\n    {\n        if (this.paused)\n        {\n            return;\n        }\n\n        const center = this.parent.center;\n        let toX = this.target.x;\n        let toY = this.target.y;\n\n        if (this.options.radius)\n        {\n            const distance = Math.sqrt(Math.pow(this.target.y - center.y, 2) + Math.pow(this.target.x - center.x, 2));\n\n            if (distance > this.options.radius)\n            {\n                const angle = Math.atan2(this.target.y - center.y, this.target.x - center.x);\n\n                toX = this.target.x - (Math.cos(angle) * this.options.radius);\n                toY = this.target.y - (Math.sin(angle) * this.options.radius);\n            }\n            else\n            {\n                return;\n            }\n        }\n\n        const deltaX = toX - center.x;\n        const deltaY = toY - center.y;\n\n        if (deltaX || deltaY)\n        {\n            if (this.options.speed)\n            {\n                if (this.options.acceleration)\n                {\n                    const angle = Math.atan2(toY - center.y, toX - center.x);\n                    const distance = Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\n\n                    if (distance)\n                    {\n                        const decelerationDistance = (Math.pow(this.velocity.x, 2) + Math.pow(this.velocity.y, 2)) / (2 * this.options.acceleration);\n\n                        if (distance > decelerationDistance)\n                        {\n                            this.velocity = {\n                                x: Math.min(this.velocity.x + this.options.acceleration * elapsed, this.options.speed),\n                                y: Math.min(this.velocity.y + this.options.acceleration * elapsed, this.options.speed)\n                            };\n                        }\n                        else\n                        {\n                            this.velocity = {\n                                x: Math.max(this.velocity.x - this.options.acceleration * this.options.speed, 0),\n                                y: Math.max(this.velocity.y - this.options.acceleration * this.options.speed, 0)\n                            };\n                        }\n                        const changeX = Math.cos(angle) * this.velocity.x;\n                        const changeY = Math.sin(angle) * this.velocity.y;\n                        const x = Math.abs(changeX) > Math.abs(deltaX) ? toX : center.x + changeX;\n                        const y = Math.abs(changeY) > Math.abs(deltaY) ? toY : center.y + changeY;\n\n                        this.parent.moveCenter(x, y);\n                        this.parent.emit('moved', { viewport: this.parent, type: 'follow' });\n                    }\n                }\n                else\n                {\n                    const angle = Math.atan2(toY - center.y, toX - center.x);\n                    const changeX = Math.cos(angle) * this.options.speed;\n                    const changeY = Math.sin(angle) * this.options.speed;\n                    const x = Math.abs(changeX) > Math.abs(deltaX) ? toX : center.x + changeX;\n                    const y = Math.abs(changeY) > Math.abs(deltaY) ? toY : center.y + changeY;\n\n                    this.parent.moveCenter(x, y);\n                    this.parent.emit('moved', { viewport: this.parent, type: 'follow' });\n                }\n            }\n            else\n            {\n                this.parent.moveCenter(toX, toY);\n                this.parent.emit('moved', { viewport: this.parent, type: 'follow' });\n            }\n        }\n    }\n}\n","import { Plugin } from './Plugin';\n\nimport type { Viewport } from '../Viewport';\nimport type { InteractionEvent } from '@pixi/interaction';\n\n/** Insets for mouse edges scrolling regions */\nexport interface IMouseEdgesInsets {\n    /** Distance from center of screen in screen pixels */\n    radius?: number | null;\n\n    /** Distance from all sides in screen pixels */\n    distance?: number | null;\n\n    /** Alternatively, set top distance (leave unset for no top scroll) */\n    top?: number | null;\n\n    /** Alternatively, set bottom distance (leave unset for no top scroll) */\n    bottom?: number | null;\n\n    /** Alternatively, set left distance (leave unset for no top scroll) */\n    left?: number | null;\n\n    /** Alternatively, set right distance (leave unset for no top scroll) */\n    right?: number | null;\n}\n\n/** Options for {@link MouseEdges}. */\nexport interface IMouseEdgesOptions extends IMouseEdgesInsets {\n    /** Speed in pixels/frame to scroll viewport */\n    speed?: number;\n\n    /** Reverse direction of scroll */\n    reverse?: boolean;\n\n    /** Don't use decelerate plugin even if it's installed */\n    noDecelerate?: boolean;\n\n    /**\n     * If using radius, use linear movement (+/- 1, +/- 1) instead of angled movement.\n     *\n     * (Math.cos(angle from center), Math.sin(angle from center))\n     */\n    linear?: boolean;\n\n    /** Allows plugin to continue working even when there's a `mousedown` event. */\n    allowButtons?: boolean;\n}\n\nconst MOUSE_EDGES_OPTIONS: Required<IMouseEdgesOptions> = {\n    radius: null,\n    distance: null,\n    top: null,\n    bottom: null,\n    left: null,\n    right: null,\n    speed: 8,\n    reverse: false,\n    noDecelerate: false,\n    linear: false,\n    allowButtons: false,\n};\n\n/**\n * Scroll viewport when mouse hovers near one of the edges.\n *\n * @event mouse-edge-start(Viewport) emitted when mouse-edge starts\n * @event mouse-edge-end(Viewport) emitted when mouse-edge ends\n */\nexport class MouseEdges extends Plugin\n{\n    /** Options used to initialize this plugin, cannot be modified later. */\n    public readonly options: Readonly<Required<IMouseEdgesOptions>>;\n\n    /** Factor from reverse option. */\n    protected readonly reverse: -1 | 1;\n\n    /** Radius squared */\n    protected readonly radiusSquared: number | null;\n\n    /** Scroll region size on the left side. */\n    protected left!: number | null;\n\n    /** Scroll region size on the top size. */\n    protected top!: number | null;\n\n    /** Scroll region size on the right side. */\n    protected right!: number | null;\n\n    /** Scroll region size on the bottom side. */\n    protected bottom!: number | null;\n\n    protected horizontal?: number | null;\n\n    protected vertical?: number | null;\n\n    /**\n     * This is called by {@link Viewport.mouseEdges}.\n     */\n    constructor(parent: Viewport, options: IMouseEdgesOptions = {})\n    {\n        super(parent);\n\n        this.options = Object.assign({}, MOUSE_EDGES_OPTIONS, options);\n        this.reverse = this.options.reverse ? 1 : -1;\n        this.radiusSquared = typeof this.options.radius === 'number' ? Math.pow(this.options.radius, 2) : null;\n\n        this.resize();\n    }\n\n    public resize(): void\n    {\n        const distance = this.options.distance;\n\n        if (distance !== null)\n        {\n            this.left = distance;\n            this.top = distance;\n            this.right = this.parent.worldScreenWidth - distance;\n            this.bottom = this.parent.worldScreenHeight - distance;\n        }\n        else if (!this.options.radius)\n        {\n            this.left = this.options.left;\n            this.top = this.options.top;\n            this.right = this.options.right === null ? null : this.parent.worldScreenWidth - this.options.right;\n            this.bottom = this.options.bottom === null ? null : this.parent.worldScreenHeight - this.options.bottom;\n        }\n    }\n\n    public down(): boolean\n    {\n        if (this.paused)\n        {\n            return false;\n        }\n        if (!this.options.allowButtons)\n        {\n            this.horizontal = this.vertical = null;\n        }\n\n        return false;\n    }\n\n    public move(event: InteractionEvent): boolean\n    {\n        if (this.paused)\n        {\n            return false;\n        }\n        if ((event.data.pointerType !== 'mouse' && event.data.identifier !== 1)\n            || (!this.options.allowButtons && event.data.buttons !== 0))\n        {\n            return false;\n        }\n\n        const x = event.data.global.x;\n        const y = event.data.global.y;\n\n        if (this.radiusSquared)\n        {\n            const center = this.parent.toScreen(this.parent.center);\n            const distance = Math.pow(center.x - x, 2) + Math.pow(center.y - y, 2);\n\n            if (distance >= this.radiusSquared)\n            {\n                const angle = Math.atan2(center.y - y, center.x - x);\n\n                if (this.options.linear)\n                {\n                    this.horizontal = Math.round(Math.cos(angle)) * this.options.speed * this.reverse * (60 / 1000);\n                    this.vertical = Math.round(Math.sin(angle)) * this.options.speed * this.reverse * (60 / 1000);\n                }\n                else\n                {\n                    this.horizontal = Math.cos(angle) * this.options.speed * this.reverse * (60 / 1000);\n                    this.vertical = Math.sin(angle) * this.options.speed * this.reverse * (60 / 1000);\n                }\n            }\n            else\n            {\n                if (this.horizontal)\n                {\n                    this.decelerateHorizontal();\n                }\n                if (this.vertical)\n                {\n                    this.decelerateVertical();\n                }\n\n                this.horizontal = this.vertical = 0;\n            }\n        }\n        else\n        {\n            if (this.left !== null && x < this.left)\n            {\n                this.horizontal = Number(this.reverse) * this.options.speed * (60 / 1000);\n            }\n            else if (this.right !== null && x > this.right)\n            {\n                this.horizontal = -1 * this.reverse * this.options.speed * (60 / 1000);\n            }\n            else\n            {\n                this.decelerateHorizontal();\n                this.horizontal = 0;\n            }\n            if (this.top !== null && y < this.top)\n            {\n                this.vertical = Number(this.reverse) * this.options.speed * (60 / 1000);\n            }\n            else if (this.bottom !== null && y > this.bottom)\n            {\n                this.vertical = -1 * this.reverse * this.options.speed * (60 / 1000);\n            }\n            else\n            {\n                this.decelerateVertical();\n                this.vertical = 0;\n            }\n        }\n\n        return false;\n    }\n\n    private decelerateHorizontal(): void\n    {\n        const decelerate = this.parent.plugins.get('decelerate', true);\n\n        if (this.horizontal && decelerate && !this.options.noDecelerate)\n        {\n            decelerate.activate({ x: (this.horizontal * this.options.speed * this.reverse) / (1000 / 60) });\n        }\n    }\n\n    private decelerateVertical(): void\n    {\n        const decelerate = this.parent.plugins.get('decelerate', true);\n\n        if (this.vertical && decelerate && !this.options.noDecelerate)\n        {\n            decelerate.activate({ y: (this.vertical * this.options.speed * this.reverse) / (1000 / 60) });\n        }\n    }\n\n    public up(): boolean\n    {\n        if (this.paused)\n        {\n            return false;\n        }\n        if (this.horizontal)\n        {\n            this.decelerateHorizontal();\n        }\n        if (this.vertical)\n        {\n            this.decelerateVertical();\n        }\n        this.horizontal = this.vertical = null;\n\n        return false;\n    }\n\n    public update(): void\n    {\n        if (this.paused)\n        {\n            return;\n        }\n\n        if (this.horizontal || this.vertical)\n        {\n            const center = this.parent.center;\n\n            if (this.horizontal)\n            {\n                center.x += this.horizontal * this.options.speed;\n            }\n            if (this.vertical)\n            {\n                center.y += this.vertical * this.options.speed;\n            }\n\n            this.parent.moveCenter(center);\n            this.parent.emit('moved', { viewport: this.parent, type: 'mouse-edges' });\n        }\n    }\n}\n","import { Plugin } from './Plugin';\nimport { Point } from '@pixi/math';\n\nimport type { IPointData } from '@pixi/math';\nimport type { InteractionEvent } from '@pixi/interaction';\nimport type { IViewportTouch } from '../InputManager';\nimport type { Viewport } from '../Viewport';\n\n/** Options for {@link Pinch}. */\nexport interface IPinchOptions\n{\n    /** Disable two-finger dragging. */\n    noDrag?: boolean;\n\n    /**\n     * Percent to modify pinch speed.\n     *\n     * @default 1\n     */\n    percent?: number;\n\n    /**\n     * Factor to multiply two-finger drag to increase speed of movement\n     *\n     * @default 1\n     */\n    factor?: number;\n\n    /** Place this point at center during zoom instead of center of two fingers */\n    center?: Point | null;\n\n    /** Axis to zoom */\n    axis?: 'all' | 'x' | 'y';\n}\n\nconst DEFAULT_PINCH_OPTIONS: Required<IPinchOptions> = {\n    noDrag: false,\n    percent: 1,\n    center: null,\n    factor: 1,\n    axis: 'all',\n};\n\n/**\n * Plugin for enabling two-finger pinching (or dragging).\n *\n * @public\n */\nexport class Pinch extends Plugin\n{\n    /** Options used to initialize this plugin. */\n    public readonly options: Required<IPinchOptions>;\n\n    /** Flags whether this plugin is active, i.e. a pointer is down on the viewport. */\n    public active = false;\n\n    /** Flags whether the viewport is being pinched. */\n    public pinching = false;\n\n    protected moved = false;\n    protected lastCenter?: IPointData | null;\n\n    /**\n     * This is called by {@link Viewport.pinch}.\n     */\n    constructor(parent: Viewport, options: IPinchOptions = {})\n    {\n        super(parent);\n        this.options = Object.assign({}, DEFAULT_PINCH_OPTIONS, options);\n    }\n\n    public down(): boolean\n    {\n        if (this.parent.input.count() >= 2)\n        {\n            this.active = true;\n\n            return true;\n        }\n\n        return false;\n    }\n\n    public isAxisX(): boolean\n    {\n        return ['all', 'x'].includes(this.options.axis);\n    }\n\n    public isAxisY(): boolean\n    {\n        return ['all', 'y'].includes(this.options.axis);\n    }\n\n    public move(e: InteractionEvent): boolean\n    {\n        if (this.paused || !this.active)\n        {\n            return false;\n        }\n\n        const x = e.data.global.x;\n        const y = e.data.global.y;\n\n        const pointers = this.parent.input.touches;\n\n        if (pointers.length >= 2)\n        {\n            const first = pointers[0] as IViewportTouch;\n            const second = pointers[1] as IViewportTouch;\n            const last = (first.last && second.last)\n                ? Math.sqrt(Math.pow(second.last.x - first.last.x, 2) + Math.pow(second.last.y - first.last.y, 2))\n                : null;\n\n            if (first.id === e.data.pointerId)\n            {\n                first.last = { x, y, data: e.data } as IPointData;\n            }\n            else if (second.id === e.data.pointerId)\n            {\n                second.last = { x, y, data: e.data } as IPointData;\n            }\n            if (last)\n            {\n                let oldPoint: IPointData | undefined;\n\n                const point = {\n                    x: (first.last as IPointData).x\n                        + ((second.last as IPointData).x - (first.last as IPointData).x) / 2,\n                    y: (first.last as IPointData).y\n                        + ((second.last as IPointData).y - (first.last as IPointData).y) / 2,\n                };\n\n                if (!this.options.center)\n                {\n                    oldPoint = this.parent.toLocal(point);\n                }\n                let dist = Math.sqrt(Math.pow(\n                    (second.last as IPointData).x - (first.last as IPointData).x, 2)\n                    + Math.pow((second.last as IPointData).y - (first.last as IPointData).y, 2));\n\n                dist = dist === 0 ? dist = 0.0000000001 : dist;\n\n                const change = (1 - last / dist) * this.options.percent\n                    * (this.isAxisX() ? this.parent.scale.x : this.parent.scale.y);\n\n                if (this.isAxisX())\n                {\n                    this.parent.scale.x += change;\n                }\n                if (this.isAxisY())\n                {\n                    this.parent.scale.y += change;\n                }\n\n                this.parent.emit('zoomed', { viewport: this.parent, type: 'pinch', center: point });\n\n                const clamp = this.parent.plugins.get('clamp-zoom', true);\n\n                if (clamp)\n                {\n                    clamp.clamp();\n                }\n                if (this.options.center)\n                {\n                    this.parent.moveCenter(this.options.center);\n                }\n                else\n                {\n                    const newPoint = this.parent.toGlobal(oldPoint as IPointData);\n\n                    this.parent.x += (point.x - newPoint.x) * this.options.factor;\n                    this.parent.y += (point.y - newPoint.y) * this.options.factor;\n                    this.parent.emit('moved', { viewport: this.parent, type: 'pinch' });\n                }\n                if (!this.options.noDrag && this.lastCenter)\n                {\n                    this.parent.x += (point.x - this.lastCenter.x) * this.options.factor;\n                    this.parent.y += (point.y - this.lastCenter.y) * this.options.factor;\n                    this.parent.emit('moved', { viewport: this.parent, type: 'pinch' });\n                }\n\n                this.lastCenter = point;\n                this.moved = true;\n            }\n            else if (!this.pinching)\n            {\n                this.parent.emit('pinch-start', this.parent);\n                this.pinching = true;\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    public up(): boolean\n    {\n        if (this.pinching)\n        {\n            if (this.parent.input.touches.length <= 1)\n            {\n                this.active = false;\n                this.lastCenter = null;\n                this.pinching = false;\n                this.moved = false;\n                this.parent.emit('pinch-end', this.parent);\n\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n","import { Plugin } from './Plugin';\nimport ease from '../ease';\n\nimport type { Viewport } from '../Viewport';\n\nexport interface ISnapOptions\n{\n    /** snap to the top-left of viewport instead of center */\n    topLeft?: boolean;\n\n    /**\n     * Friction/frame to apply if decelerate is active\n     *\n     * @default 0.8\n     */\n    friction?: number;\n\n    /**\n     * @default 1000\n     */\n    time?: number;\n\n    /** Easing function or name (see http://easings.net/ for supported names) */\n    ease?: any;\n\n    /**\n     * Pause snapping with any user input on the viewport\n     *\n     * @default true\n     */\n    interrupt?: boolean;\n\n    /**\n     * Removes this plugin after snapping is complete\n     *\n     * @default false\n     */\n    removeOnComplete?: boolean;\n\n    /**\n     * Removes this plugin if interrupted by any user input\n     *\n     * @default false\n     */\n    removeOnInterrupt?: boolean;\n\n    /**\n     * Starts the snap immediately regardless of whether the viewport is at the desired location\n     *\n     * @default false\n     */\n    forceStart?: boolean;\n}\n\nconst DEFAULT_SNAP_OPTIONS: Required<ISnapOptions> = {\n    topLeft: false,\n    friction: 0.8,\n    time: 1000,\n    ease: 'easeInOutSine',\n    interrupt: true,\n    removeOnComplete: false,\n    removeOnInterrupt: false,\n    forceStart: false\n};\n\n/**\n * @event snap-start(Viewport) emitted each time a snap animation starts\n * @event snap-restart(Viewport) emitted each time a snap resets because of a change in viewport size\n * @event snap-end(Viewport) emitted each time snap reaches its target\n * @event snap-remove(Viewport) emitted if snap plugin is removed\n */\nexport class Snap extends Plugin\n{\n    public readonly options: Required<ISnapOptions>;\n    public ease?: any;\n    public x: number;\n    public y: number;\n\n    protected percent?: number;\n    protected snapping?: { time: number } | null;\n    protected deltaX?: number;\n    protected deltaY?: number;\n    protected startX?: number;\n    protected startY?: number;\n\n    /**\n     * This is called by {@link Viewport.snap}.\n     */\n    constructor(parent: Viewport, x: number, y: number, options: ISnapOptions = {})\n    {\n        super(parent);\n        this.options = Object.assign({}, DEFAULT_SNAP_OPTIONS, options);\n        this.ease = ease(options.ease, 'easeInOutSine');\n        this.x = x;\n        this.y = y;\n\n        if (this.options.forceStart)\n        {\n            this.snapStart();\n        }\n    }\n\n    public snapStart(): void\n    {\n        this.percent = 0;\n        this.snapping = { time: 0 };\n        const current = this.options.topLeft ? this.parent.corner : this.parent.center;\n\n        this.deltaX = this.x - current.x;\n        this.deltaY = this.y - current.y;\n        this.startX = current.x;\n        this.startY = current.y;\n        this.parent.emit('snap-start', this.parent);\n    }\n\n    public wheel(): boolean\n    {\n        if (this.options.removeOnInterrupt)\n        {\n            this.parent.plugins.remove('snap');\n        }\n\n        return false;\n    }\n\n    public down(): boolean\n    {\n        if (this.options.removeOnInterrupt)\n        {\n            this.parent.plugins.remove('snap');\n        }\n        else if (this.options.interrupt)\n        {\n            this.snapping = null;\n        }\n\n        return false;\n    }\n\n    public up(): boolean\n    {\n        if (this.parent.input.count() === 0)\n        {\n            const decelerate = this.parent.plugins.get('decelerate', true);\n\n            if (decelerate && (decelerate.x || decelerate.y))\n            {\n                decelerate.percentChangeX = decelerate.percentChangeY = this.options.friction;\n            }\n        }\n\n        return false;\n    }\n\n    public update(elapsed: number): void\n    {\n        if (this.paused)\n        {\n            return;\n        }\n        if (this.options.interrupt && this.parent.input.count() !== 0)\n        {\n            return;\n        }\n        if (!this.snapping)\n        {\n            const current = this.options.topLeft ? this.parent.corner : this.parent.center;\n\n            if (current.x !== this.x || current.y !== this.y)\n            {\n                this.snapStart();\n            }\n        }\n        else\n        {\n            const snapping = this.snapping;\n\n            snapping.time += elapsed;\n            let finished;\n            let x;\n            let y;\n\n            const startX = this.startX as number;\n            const startY = this.startY as number;\n            const deltaX = this.deltaX as number;\n            const deltaY = this.deltaY as number;\n\n            if (snapping.time > this.options.time)\n            {\n                finished = true;\n                x = startX + deltaX;\n                y = startY + deltaY;\n            }\n            else\n            {\n                const percent = this.ease(snapping.time, 0, 1, this.options.time);\n\n                x = startX + (deltaX * percent);\n                y = startY + (deltaY * percent);\n            }\n            if (this.options.topLeft)\n            {\n                this.parent.moveCorner(x, y);\n            }\n            else\n            {\n                this.parent.moveCenter(x, y);\n            }\n\n            this.parent.emit('moved', { viewport: this.parent, type: 'snap' });\n\n            if (finished)\n            {\n                if (this.options.removeOnComplete)\n                {\n                    this.parent.plugins.remove('snap');\n                }\n                this.parent.emit('snap-end', this.parent);\n                this.snapping = null;\n            }\n        }\n    }\n}\n","import { Plugin } from './Plugin';\nimport ease from '../ease';\n\nimport type { Point } from '@pixi/math';\nimport type { Viewport } from '../Viewport';\n\n/** Options for {@link SnapZoom}. */\nexport interface ISnapZoomOptions\n{\n    /** the desired width to snap (to maintain aspect ratio, choose only width or height) */\n    width?: number;\n\n    /** the desired height to snap (to maintain aspect ratio, choose only width or height) */\n    height?: number;\n\n    /**\n     * time for snapping in ms\n     *\n     * @default 1000\n     */\n    time?: number;\n\n    /** ease function or name (see http://easings.net/ for supported names) */\n    ease?: any;\n\n    /** Place this point at center during zoom instead of center of the viewport */\n    center?: Point | null;\n\n    /**\n     * Pause snapping with any user input on the viewport\n     *\n     * @default true\n     */\n    interrupt?: boolean;\n\n    /**\n     * Removes this plugin after snapping is complete\n     *\n     * @default false\n     */\n    removeOnComplete?: boolean;\n\n    /**\n     * Removes this plugin if interrupted by any user input\n     *\n     * @default false\n     */\n    removeOnInterrupt?: boolean;\n\n    /**\n     * Starts the snap immediately regardless of whether the viewport is at the desired zoom\n     *\n     * @default false\n     */\n    forceStart?: boolean;\n\n    /**\n     * Zoom but do not move\n     *\n     * @default false\n     */\n    noMove?: boolean;\n}\n\nconst DEFAULT_SNAP_ZOOM_OPTIONS: Required<ISnapZoomOptions> = {\n    width: 0,\n    height: 0,\n    time: 1000,\n    ease: 'easeInOutSine',\n    center: null,\n    interrupt: true,\n    removeOnComplete: false,\n    removeOnInterrupt: false,\n    forceStart: false,\n    noMove: false\n};\n\n/**\n * @event snap-zoom-start(Viewport) emitted each time a fit animation starts\n * @event snap-zoom-end(Viewport) emitted each time fit reaches its target\n * @event snap-zoom-end(Viewport) emitted each time fit reaches its target\n */\nexport class SnapZoom extends Plugin\n{\n    public readonly options: Required<ISnapZoomOptions>;\n\n    protected ease: any;\n    protected xScale: number;\n    protected yScale: number;\n    protected xIndependent: boolean;\n    protected yIndependent: boolean;\n    protected snapping?: {\n        time: number;\n        startX: number;\n        startY: number;\n        deltaX: number;\n        deltaY: number;\n    } | null;\n\n    /**\n     * This is called by {@link Viewport.snapZoom}.\n     */\n    constructor(parent: Viewport, options: ISnapZoomOptions = {})\n    {\n        super(parent);\n\n        this.options = Object.assign({}, DEFAULT_SNAP_ZOOM_OPTIONS, options);\n        this.ease = ease(this.options.ease);\n\n        // Assign defaults for typescript.\n        this.xIndependent = false;\n        this.yIndependent = false;\n        this.xScale = 0;\n        this.yScale = 0;\n\n        if (this.options.width > 0)\n        {\n            this.xScale = parent.screenWidth / this.options.width;\n            this.xIndependent = true;\n        }\n        if (this.options.height > 0)\n        {\n            this.yScale = parent.screenHeight / this.options.height;\n            this.yIndependent = true;\n        }\n\n        this.xScale = this.xIndependent ? (this.xScale as number) : (this.yScale as number);\n        this.yScale = this.yIndependent ? (this.yScale as number) : this.xScale;\n\n        if (this.options.time === 0)\n        {\n            // TODO: Fix this\n            // @ts-expect-error todo\n            parent.container.scale.x = this.xScale;\n\n            // TODO: Fix this\n            // @ts-expect-error todo\n            parent.container.scale.y = this.yScale;\n\n            if (this.options.removeOnComplete)\n            {\n                this.parent.plugins.remove('snap-zoom');\n            }\n        }\n        else if (options.forceStart)\n        {\n            this.createSnapping();\n        }\n    }\n\n    private createSnapping(): void\n    {\n        const startWorldScreenWidth = this.parent.worldScreenWidth;\n        const startWorldScreenHeight = this.parent.worldScreenHeight;\n        const endWorldScreenWidth = this.parent.screenWidth / this.xScale;\n        const endWorldScreenHeight = this.parent.screenHeight / this.yScale;\n\n        this.snapping = {\n            time: 0,\n            startX: startWorldScreenWidth,\n            startY: startWorldScreenHeight,\n            deltaX: endWorldScreenWidth - startWorldScreenWidth,\n            deltaY: endWorldScreenHeight - startWorldScreenHeight\n        };\n\n        this.parent.emit('snap-zoom-start', this.parent);\n    }\n\n    public resize(): void\n    {\n        this.snapping = null;\n\n        if (this.options.width > 0)\n        {\n            this.xScale = this.parent.screenWidth / this.options.width;\n        }\n        if (this.options.height > 0)\n        {\n            this.yScale = this.parent.screenHeight / this.options.height;\n        }\n        this.xScale = this.xIndependent ? this.xScale : this.yScale;\n        this.yScale = this.yIndependent ? this.yScale : this.xScale;\n    }\n\n    public wheel(): boolean\n    {\n        if (this.options.removeOnInterrupt)\n        {\n            this.parent.plugins.remove('snap-zoom');\n        }\n\n        return false;\n    }\n\n    public down(): boolean\n    {\n        if (this.options.removeOnInterrupt)\n        {\n            this.parent.plugins.remove('snap-zoom');\n        }\n        else if (this.options.interrupt)\n        {\n            this.snapping = null;\n        }\n\n        return false;\n    }\n\n    public update(elapsed: number): void\n    {\n        if (this.paused)\n        {\n            return;\n        }\n        if (this.options.interrupt && this.parent.input.count() !== 0)\n        {\n            return;\n        }\n\n        let oldCenter: Point | undefined;\n\n        if (!this.options.center && !this.options.noMove)\n        {\n            oldCenter = this.parent.center;\n        }\n        if (!this.snapping)\n        {\n            if (this.parent.scale.x !== this.xScale || this.parent.scale.y !== this.yScale)\n            {\n                this.createSnapping();\n            }\n        }\n        else if (this.snapping)\n        {\n            const snapping = this.snapping;\n\n            snapping.time += elapsed;\n\n            if (snapping.time >= this.options.time)\n            {\n                this.parent.scale.set(this.xScale, this.yScale);\n                if (this.options.removeOnComplete)\n                {\n                    this.parent.plugins.remove('snap-zoom');\n                }\n                this.parent.emit('snap-zoom-end', this.parent);\n                this.snapping = null;\n            }\n            else\n            {\n                const snapping = this.snapping;\n                const worldScreenWidth = this.ease(snapping.time, snapping.startX, snapping.deltaX, this.options.time);\n                const worldScreenHeight = this.ease(snapping.time, snapping.startY, snapping.deltaY, this.options.time);\n\n                this.parent.scale.x = this.parent.screenWidth / worldScreenWidth;\n                this.parent.scale.y = this.parent.screenHeight / worldScreenHeight;\n            }\n            const clamp = this.parent.plugins.get('clamp-zoom', true);\n\n            if (clamp)\n            {\n                clamp.clamp();\n            }\n            if (!this.options.noMove)\n            {\n                if (!this.options.center)\n                {\n                    this.parent.moveCenter(oldCenter as Point);\n                }\n                else\n                {\n                    this.parent.moveCenter(this.options.center);\n                }\n            }\n        }\n    }\n\n    public resume(): void\n    {\n        this.snapping = null;\n        super.resume();\n    }\n}\n","import { Plugin } from './Plugin';\nimport { IPointData, Point } from '@pixi/math';\n\nimport type { Viewport } from '../Viewport';\n\n/** Options for {@link Wheel}. */\nexport interface IWheelOptions\n{\n    /**\n     * Percent to scroll with each spin\n     *\n     * @default 0.1\n     */\n    percent?: number;\n\n    /**\n     * smooth the zooming by providing the number of frames to zoom between wheel spins\n     *\n     * @default false\n     */\n    smooth?: false | number;\n\n    /**\n     * Stop smoothing with any user input on the viewport\n     *\n     * @default true\n     */\n    interrupt?: boolean;\n\n    /**\n     * Reverse the direction of the scroll\n     *\n     * @default false\n     */\n    reverse?: boolean;\n\n    /**\n     * Place this point at center during zoom instead of current mouse position\n     *\n     * @default null\n     */\n    center?: Point | null;\n\n    /**\n     * Scaling factor for non-DOM_DELTA_PIXEL scrolling events\n     *\n     * @default 20\n     */\n    lineHeight?: number;\n\n    /**\n     * Axis to zoom\n     *\n     * @default 'all'\n     */\n    axis?: 'all' | 'x' | 'y';\n\n    /**\n     * pinch the trackpad to zoom\n     */\n    trackpadPinch?: boolean;\n\n    /**\n     * zooms on wheel spin (use this as an alternative to drag.options.wheel)\n     */\n    wheelZoom?: boolean;\n}\n\nconst DEFAULT_WHEEL_OPTIONS: Required<IWheelOptions> = {\n    percent: 0.1,\n    smooth: false,\n    interrupt: true,\n    reverse: false,\n    center: null,\n    lineHeight: 20,\n    axis: 'all',\n    trackpadPinch: false,\n    wheelZoom: true,\n};\n\n/**\n * Plugin for handling wheel scrolling for viewport zoom.\n *\n * @event wheel({wheel: {dx, dy, dz}, event, viewport})\n */\nexport class Wheel extends Plugin\n{\n    public readonly options: Required<IWheelOptions>;\n\n    protected smoothing?: IPointData | null;\n    protected smoothingCenter?: Point | null;\n    protected smoothingCount?: number;\n\n    /**\n     * This is called by {@link Viewport.wheel}.\n     */\n    constructor(parent: Viewport, options: IWheelOptions = {})\n    {\n        super(parent);\n        this.options = Object.assign({}, DEFAULT_WHEEL_OPTIONS, options);\n    }\n\n    public down(): boolean\n    {\n        if (this.options.interrupt)\n        {\n            this.smoothing = null;\n        }\n\n        return false;\n    }\n\n    protected isAxisX(): boolean\n    {\n        return ['all', 'x'].includes(this.options.axis);\n    }\n\n    protected isAxisY(): boolean\n    {\n        return ['all', 'y'].includes(this.options.axis);\n    }\n\n    public update(): void\n    {\n        if (this.smoothing)\n        {\n            const point = this.smoothingCenter;\n            const change = this.smoothing;\n            let oldPoint;\n\n            if (!this.options.center)\n            {\n                oldPoint = this.parent.toLocal(point as IPointData);\n            }\n            if (this.isAxisX())\n            {\n                this.parent.scale.x += change.x;\n            }\n            if (this.isAxisY())\n            {\n                this.parent.scale.y += change.y;\n            }\n\n            this.parent.emit('zoomed', { viewport: this.parent, type: 'wheel' });\n            const clamp = this.parent.plugins.get('clamp-zoom', true);\n\n            if (clamp)\n            {\n                clamp.clamp();\n            }\n            if (this.options.center)\n            {\n                this.parent.moveCenter(this.options.center);\n            }\n            else\n            {\n                const newPoint = this.parent.toGlobal(oldPoint as IPointData);\n\n                this.parent.x += (point as IPointData).x - newPoint.x;\n                this.parent.y += (point as IPointData).y - newPoint.y;\n            }\n\n            this.parent.emit('moved', { viewport: this.parent, type: 'wheel' });\n            (this.smoothingCount as number)++;\n\n            if (this.smoothingCount as number >= this.options.smooth)\n            {\n                this.smoothing = null;\n            }\n        }\n    }\n\n    private pinch(e: WheelEvent)\n    {\n        const point = this.parent.input.getPointerPosition(e);\n        const step = -e.deltaY * (e.deltaMode ? this.options.lineHeight : 1) / 200;\n        const change = Math.pow(2, (1 + this.options.percent) * step);\n\n        let oldPoint: IPointData | undefined;\n\n        if (!this.options.center)\n        {\n            oldPoint = this.parent.toLocal(point);\n        }\n        if (this.isAxisX())\n        {\n            this.parent.scale.x *= change;\n        }\n        if (this.isAxisY())\n        {\n            this.parent.scale.y *= change;\n        }\n        this.parent.emit('zoomed', { viewport: this.parent, type: 'wheel' });\n        const clamp = this.parent.plugins.get('clamp-zoom', true);\n\n        if (clamp)\n        {\n            clamp.clamp();\n        }\n        if (this.options.center)\n        {\n            this.parent.moveCenter(this.options.center);\n        }\n        else\n        {\n            const newPoint = this.parent.toGlobal(oldPoint as IPointData);\n\n            this.parent.x += point.x - newPoint.x;\n            this.parent.y += point.y - newPoint.y;\n        }\n        this.parent.emit('moved', { viewport: this.parent, type: 'wheel' });\n        this.parent.emit('wheel',\n            { wheel: { dx: e.deltaX, dy: e.deltaY, dz: e.deltaZ }, event: e, viewport: this.parent });\n    }\n\n    public wheel(e: WheelEvent): boolean\n    {\n        if (this.paused)\n        {\n            return false;\n        }\n\n        if (e.ctrlKey && this.options.trackpadPinch)\n        {\n            this.pinch(e);\n        }\n        else if (this.options.wheelZoom)\n        {\n            const point = this.parent.input.getPointerPosition(e);\n            const sign = this.options.reverse ? -1 : 1;\n            const step = sign * -e.deltaY * (e.deltaMode ? this.options.lineHeight : 1) / 500;\n            const change = Math.pow(2, (1 + this.options.percent) * step);\n\n            if (this.options.smooth)\n            {\n                const original = {\n                    x: this.smoothing ? this.smoothing.x * (this.options.smooth - (this.smoothingCount as number)) : 0,\n                    y: this.smoothing ? this.smoothing.y * (this.options.smooth - (this.smoothingCount as number)) : 0\n                };\n\n                this.smoothing = {\n                    x: ((this.parent.scale.x + original.x) * change - this.parent.scale.x) / this.options.smooth,\n                    y: ((this.parent.scale.y + original.y) * change - this.parent.scale.y) / this.options.smooth,\n                };\n                this.smoothingCount = 0;\n                this.smoothingCenter = point;\n            }\n            else\n            {\n                let oldPoint: IPointData | undefined;\n\n                if (!this.options.center)\n                {\n                    oldPoint = this.parent.toLocal(point);\n                }\n                if (this.isAxisX())\n                {\n                    this.parent.scale.x *= change;\n                }\n                if (this.isAxisY())\n                {\n                    this.parent.scale.y *= change;\n                }\n                this.parent.emit('zoomed', { viewport: this.parent, type: 'wheel' });\n                const clamp = this.parent.plugins.get('clamp-zoom', true);\n\n                if (clamp)\n                {\n                    clamp.clamp();\n                }\n                if (this.options.center)\n                {\n                    this.parent.moveCenter(this.options.center);\n                }\n                else\n                {\n                    const newPoint = this.parent.toGlobal(oldPoint as IPointData);\n\n                    this.parent.x += point.x - newPoint.x;\n                    this.parent.y += point.y - newPoint.y;\n                }\n            }\n\n            this.parent.emit('moved', { viewport: this.parent, type: 'wheel' });\n            this.parent.emit('wheel',\n                { wheel: { dx: e.deltaX, dy: e.deltaY, dz: e.deltaZ }, event: e, viewport: this.parent });\n        }\n\n        return !this.parent.options.passiveWheel;\n    }\n}\n","import { Point, Rectangle } from '@pixi/math';\n\nimport type { IPointData } from '@pixi/math';\nimport type { InteractionEvent } from '@pixi/interaction';\nimport type { Viewport } from './Viewport';\n\nexport interface IViewportTouch {\n    id: number;\n    last: IPointData | null;\n}\n\n/**\n * Handles all input for Viewport\n *\n * @internal\n * @ignore\n * @private\n */\nexport class InputManager\n{\n    public readonly viewport: Viewport;\n\n    public clickedAvailable?: boolean;\n    public isMouseDown?: boolean;\n    public last?: Point | null;\n    public wheelFunction?: (e: WheelEvent) => void;\n    /** List of active touches on viewport */\n    public touches: IViewportTouch[];\n\n    constructor(viewport: Viewport)\n    {\n        this.viewport = viewport;\n        this.touches = [];\n\n        this.addListeners();\n    }\n\n    /** Add input listeners */\n    private addListeners()\n    {\n        this.viewport.interactive = true;\n        if (!this.viewport.forceHitArea)\n        {\n            this.viewport.hitArea = new Rectangle(0, 0, this.viewport.worldWidth, this.viewport.worldHeight);\n        }\n        this.viewport.on('pointerdown', this.down, this);\n        this.viewport.on('pointermove', this.move, this);\n        this.viewport.on('pointerup', this.up, this);\n        this.viewport.on('pointerupoutside', this.up, this);\n        this.viewport.on('pointercancel', this.up, this);\n        this.viewport.on('pointerout', this.up, this);\n        this.wheelFunction = (e) => this.handleWheel(e);\n        this.viewport.options.divWheel.addEventListener(\n            'wheel',\n            this.wheelFunction as any,\n            { passive: this.viewport.options.passiveWheel });\n        this.isMouseDown = false;\n    }\n\n    /**\n     * Removes all event listeners from viewport\n     * (useful for cleanup of wheel when removing viewport)\n     */\n    public destroy(): void\n    {\n        this.viewport.options.divWheel.removeEventListener('wheel', this.wheelFunction as any);\n    }\n\n    /**\n     * handle down events for viewport\n     *\n     * @param {PIXI.InteractionEvent} event\n     */\n    public down(event: InteractionEvent)\n    {\n        if (this.viewport.pause || !this.viewport.worldVisible)\n        {\n            return;\n        }\n        if (event.data.pointerType === 'mouse')\n        {\n            this.isMouseDown = true;\n        }\n        else if (!this.get(event.data.pointerId))\n        {\n            this.touches.push({ id: event.data.pointerId, last: null });\n        }\n        if (this.count() === 1)\n        {\n            this.last = event.data.global.clone();\n\n            // clicked event does not fire if viewport is decelerating or bouncing\n            const decelerate = this.viewport.plugins.get('decelerate', true);\n            const bounce = this.viewport.plugins.get('bounce', true);\n\n            if ((!decelerate || !decelerate.isActive()) && (!bounce || !bounce.isActive()))\n            {\n                this.clickedAvailable = true;\n            }\n            else\n            {\n                this.clickedAvailable = false;\n            }\n        }\n        else\n        {\n            this.clickedAvailable = false;\n        }\n\n        const stop = this.viewport.plugins.down(event);\n\n        if (stop && this.viewport.options.stopPropagation)\n        {\n            event.stopPropagation();\n        }\n    }\n\n    /** Clears all pointer events */\n    public clear(): void\n    {\n        this.isMouseDown = false;\n        this.touches = [];\n        this.last = null;\n    }\n\n    /**\n     * @param {number} change\n     * @returns whether change exceeds threshold\n     */\n    public checkThreshold(change: number): boolean\n    {\n        if (Math.abs(change) >= this.viewport.threshold)\n        {\n            return true;\n        }\n\n        return false;\n    }\n\n    /** Handle move events for viewport */\n    public move(event: InteractionEvent): void\n    {\n        if (this.viewport.pause || !this.viewport.worldVisible)\n        {\n            return;\n        }\n\n        const stop = this.viewport.plugins.move(event);\n\n        if (this.clickedAvailable && this.last)\n        {\n            const distX = event.data.global.x - this.last.x;\n            const distY = event.data.global.y - this.last.y;\n\n            if (this.checkThreshold(distX) || this.checkThreshold(distY))\n            {\n                this.clickedAvailable = false;\n            }\n        }\n\n        if (stop && this.viewport.options.stopPropagation)\n        {\n            event.stopPropagation();\n        }\n    }\n\n    /** Handle up events for viewport */\n    public up(event: InteractionEvent): void\n    {\n        if (this.viewport.pause || !this.viewport.worldVisible)\n        {\n            return;\n        }\n\n        if (event.data.pointerType === 'mouse')\n        {\n            this.isMouseDown = false;\n        }\n\n        if (event.data.pointerType !== 'mouse')\n        {\n            this.remove(event.data.pointerId);\n        }\n\n        const stop = this.viewport.plugins.up(event);\n\n        if (this.clickedAvailable && this.count() === 0 && this.last)\n        {\n            this.viewport.emit('clicked', {\n                event,\n                screen: this.last,\n                world: this.viewport.toWorld(this.last),\n                viewport: this\n            });\n            this.clickedAvailable = false;\n        }\n\n        if (stop && this.viewport.options.stopPropagation)\n        {\n            event.stopPropagation();\n        }\n    }\n\n    /** Gets pointer position if this.interaction is set */\n    public getPointerPosition(event: WheelEvent): Point\n    {\n        const point = new Point();\n\n        if (this.viewport.options.interaction)\n        {\n            this.viewport.options.interaction.mapPositionToPoint(point, event.clientX, event.clientY);\n        }\n        else\n        {\n            point.x = event.clientX;\n            point.y = event.clientY;\n        }\n\n        return point;\n    }\n\n    /** Handle wheel events */\n    public handleWheel(event: WheelEvent): void\n    {\n        if (this.viewport.pause || !this.viewport.worldVisible)\n        {\n            return;\n        }\n\n        // do not handle events coming from other elements\n        if (this.viewport.options.interaction\n            && (this.viewport.options.interaction as any).interactionDOMElement !== event.target)\n        {\n            return;\n        }\n\n        // only handle wheel events where the mouse is over the viewport\n        const point = this.viewport.toLocal(this.getPointerPosition(event));\n\n        if (this.viewport.left <= point.x\n            && point.x <= this.viewport.right\n            && this.viewport.top <= point.y\n            && point.y <= this.viewport.bottom)\n        {\n            const stop = this.viewport.plugins.wheel(event);\n\n            if (stop && !this.viewport.options.passiveWheel)\n            {\n                event.preventDefault();\n            }\n        }\n    }\n\n    public pause(): void\n    {\n        this.touches = [];\n        this.isMouseDown = false;\n    }\n\n    /** Get touch by id */\n    public get(id: number): IViewportTouch | null\n    {\n        for (const touch of this.touches)\n        {\n            if (touch.id === id)\n            {\n                return touch;\n            }\n        }\n\n        return null;\n    }\n\n    /** Remove touch by number */\n    remove(id: number): void\n    {\n        for (let i = 0; i < this.touches.length; i++)\n        {\n            if (this.touches[i].id === id)\n            {\n                this.touches.splice(i, 1);\n\n                return;\n            }\n        }\n    }\n\n    /**\n     * @returns {number} count of mouse/touch pointers that are down on the viewport\n     */\n    count(): number\n    {\n        return (this.isMouseDown ? 1 : 0) + this.touches.length;\n    }\n}\n","import type {\n    Animate,\n    Bounce,\n    Clamp,\n    ClampZoom,\n    Decelerate,\n    Drag,\n    Follow,\n    MouseEdges,\n    Pinch,\n    Plugin,\n    Snap,\n    SnapZoom,\n    Wheel,\n} from './plugins';\nimport type { InteractionEvent } from '@pixi/interaction';\nimport type { Viewport } from './Viewport';\n\nconst PLUGIN_ORDER = [\n    'drag',\n    'pinch',\n    'wheel',\n    'follow',\n    'mouse-edges',\n    'decelerate',\n    'animate',\n    'bounce',\n    'snap-zoom',\n    'clamp-zoom',\n    'snap',\n    'clamp',\n];\n\n/**\n * Use this to access current plugins or add user-defined plugins\n *\n * @public\n */\nexport class PluginManager\n{\n    /** Maps mounted plugins by their type */\n    public plugins: Partial<Record<string, Plugin>>;\n\n    /**\n     * List of plugins mounted\n     *\n     * This list is kept sorted by the internal priority of plugins (hard-coded).\n     */\n    public list: Array<Plugin>;\n\n    /** The viewport using the plugins managed by `this`. */\n    public readonly viewport: Viewport;\n\n    /** This is called by {@link Viewport} to initialize the {@link Viewport.plugins plugins}. */\n    constructor(viewport: Viewport)\n    {\n        this.viewport = viewport;\n        this.list = [];\n        this.plugins = {};\n    }\n\n    /**\n     * Inserts a named plugin or a user plugin into the viewport\n     * default plugin order: 'drag', 'pinch', 'wheel', 'follow', 'mouse-edges', 'decelerate', 'bounce',\n     * 'snap-zoom', 'clamp-zoom', 'snap', 'clamp'\n     *\n     * @param {string} name of plugin\n     * @param {Plugin} plugin - instantiated Plugin class\n     * @param {number} index to insert userPlugin (otherwise inserts it at the end)\n     */\n    public add(name: string, plugin: Plugin, index: number = PLUGIN_ORDER.length)\n    {\n        this.plugins[name] = plugin;\n\n        const current = PLUGIN_ORDER.indexOf(name);\n\n        if (current !== -1)\n        {\n            PLUGIN_ORDER.splice(current, 1);\n        }\n\n        PLUGIN_ORDER.splice(index, 0, name);\n        this.sort();\n    }\n\n    public get(name: 'animate', ignorePaused?: boolean): Animate | undefined | null;\n    public get(name: 'bounce', ignorePaused?: boolean): Bounce | undefined | null;\n    public get(name: 'clamp', ignorePaused?: boolean): Clamp | undefined | null;\n    public get(name: 'clamp-zoom', ignorePaused?: boolean): ClampZoom | undefined | null;\n    public get(name: 'decelerate', ignorePaused?: boolean): Decelerate | undefined | null;\n    public get(name: 'drag', ignorePaused?: boolean): Drag | undefined | null;\n    public get(name: 'follow', ignorePaused?: boolean): Follow | undefined | null;\n    public get(name: 'mouse-edges', ignorePaused?: boolean): MouseEdges | undefined | null;\n    public get(name: 'pinch', ignorePaused?: boolean): Pinch | undefined | null;\n    public get(name: 'snap', ignorePaused?: boolean): Snap | undefined | null;\n    public get(name: 'snap-zoom', ignorePaused?: boolean): SnapZoom | undefined | null;\n    public get(name: 'wheel', ignorePaused?: boolean): Wheel | undefined | null;\n    public get<T extends Plugin = Plugin>(name: string, ignorePaused?: boolean): T | undefined | null;\n\n    /**\n     * Get plugin\n     *\n     * @param {string} name of plugin\n     * @param {boolean} [ignorePaused] return null if plugin is paused\n     */\n    public get<T extends Plugin = Plugin>(name: string, ignorePaused?: boolean): T | undefined | null\n    {\n        if (ignorePaused)\n        {\n            if (this.plugins[name]?.paused)\n            {\n                return null;\n            }\n        }\n\n        return this.plugins[name] as T;\n    }\n\n    /**\n     * Update all active plugins\n     *\n     * @internal\n     * @ignore\n     * @param {number} elapsed type in milliseconds since last update\n     */\n    public update(elapsed: number): void\n    {\n        for (const plugin of this.list)\n        {\n            plugin.update(elapsed);\n        }\n    }\n\n    /**\n     * Resize all active plugins\n     *\n     * @internal\n     * @ignore\n     */\n    public resize(): void\n    {\n        for (const plugin of this.list)\n        {\n            plugin.resize();\n        }\n    }\n\n    /** Clamps and resets bounce and decelerate (as needed) after manually moving viewport */\n    public reset(): void\n    {\n        for (const plugin of this.list)\n        {\n            plugin.reset();\n        }\n    }\n\n    /** removes all installed plugins */\n    public removeAll(): void\n    {\n        this.plugins = {};\n        this.sort();\n    }\n\n    /**\n     * Removes installed plugin\n     *\n     * @param {string} name of plugin (e.g., 'drag', 'pinch')\n     */\n    public remove(name: string): void\n    {\n        if (this.plugins[name])\n        {\n            delete this.plugins[name];\n            this.viewport.emit(`${name}-remove`);\n            this.sort();\n        }\n    }\n\n    /**\n     * Pause plugin\n     *\n     * @param {string} name of plugin (e.g., 'drag', 'pinch')\n     */\n    public pause(name: string): void\n    {\n        this.plugins[name]?.pause();\n    }\n\n    /**\n     * Resume plugin\n     *\n     * @param {string} name of plugin (e.g., 'drag', 'pinch')\n     */\n    public resume(name: string): void\n    {\n        this.plugins[name]?.resume();\n    }\n\n    /**\n     * Sort plugins according to PLUGIN_ORDER\n     *\n     * @internal\n     * @ignore\n     */\n    public sort()\n    {\n        this.list = [];\n\n        for (const plugin of PLUGIN_ORDER)\n        {\n            if (this.plugins[plugin])\n            {\n                this.list.push(this.plugins[plugin] as Plugin);\n            }\n        }\n    }\n\n    /**\n     * Handle down for all plugins\n     *\n     * @internal\n     * @ignore\n     */\n    public down(event: InteractionEvent): boolean\n    {\n        let stop = false;\n\n        for (const plugin of this.list)\n        {\n            if (plugin.down(event))\n            {\n                stop = true;\n            }\n        }\n\n        return stop;\n    }\n\n    /**\n     * Handle move for all plugins\n     *\n     * @internal\n     * @ignore\n     */\n    public move(event: InteractionEvent): boolean\n    {\n        let stop = false;\n\n        for (const plugin of this.viewport.plugins.list)\n        {\n            if (plugin.move(event))\n            {\n                stop = true;\n            }\n        }\n\n        return stop;\n    }\n\n    /**\n     * Handle up for all plugins\n     *\n     * @internal\n     * @ignore\n     */\n    public up(event: InteractionEvent): boolean\n    {\n        let stop = false;\n\n        for (const plugin of this.list)\n        {\n            if (plugin.up(event))\n            {\n                stop = true;\n            }\n        }\n\n        return stop;\n    }\n\n    /**\n     * Handle wheel event for all plugins\n     *\n     * @internal\n     * @ignore\n     */\n    public wheel(e: WheelEvent): boolean\n    {\n        let result = false;\n\n        for (const plugin of this.list)\n        {\n            if (plugin.wheel(e))\n            {\n                result = true;\n            }\n        }\n\n        return result;\n    }\n}\n","import { Container } from '@pixi/display';\nimport { Point, Rectangle } from '@pixi/math';\nimport { Ticker } from '@pixi/ticker';\n\nimport { InputManager } from './InputManager';\nimport { PluginManager } from './PluginManager';\nimport {\n    Animate, IAnimateOptions,\n    Bounce, IBounceOptions,\n    Clamp, IClampOptions,\n    ClampZoom, IClampZoomOptions,\n    Decelerate, IDecelerateOptions,\n    Drag, IDragOptions,\n    Follow, IFollowOptions,\n    MouseEdges, IMouseEdgesOptions,\n    Pinch, IPinchOptions,\n    Snap, ISnapOptions,\n    SnapZoom, ISnapZoomOptions,\n    Wheel, IWheelOptions,\n} from './plugins';\n\nimport type { DisplayObject, IDestroyOptions } from '@pixi/display';\nimport type { IHitArea, InteractionManager } from '@pixi/interaction';\n\n/** Options for {@link Viewport}. */\nexport interface IViewportOptions {\n    /** @default window.innerWidth */\n    screenWidth?: number;\n\n    /** @default window.innerHeight */\n    screenHeight?: number;\n\n    /** @default this.width */\n    worldWidth?: number | null;\n\n    /** @default this.height */\n    worldHeight?: number | null;\n\n    /**\n     * Number of pixels to move to trigger an input event (e.g., drag, pinch) or disable a clicked event\n     *\n     * @default 5\n     */\n    threshold?: number;\n\n    /**\n     * Whether the 'wheel' event is set to passive (note: if false, e.preventDefault() will be called when wheel\n     * is used over the viewport)\n     *\n     * @default true\n     */\n    passiveWheel?: boolean;\n\n    /**\n     * Whether to stopPropagation of events that impact the viewport (except wheel events, see options.passiveWheel)\n     */\n    stopPropagation?: boolean;\n\n    /**\n     * Change the default hitArea from world size to a new value\n     */\n    forceHitArea?: Rectangle | null;\n\n    /**\n     * Set this if you want to manually call update() function on each frame\n     *\n     * @default false\n     */\n    noTicker?: boolean;\n\n    /**\n     * InteractionManager, available from instantiated `WebGLRenderer/CanvasRenderer.plugins.interaction`\n     *\n     * It's used to calculate pointer postion relative to canvas location on screen\n     */\n    interaction?: InteractionManager | null;\n\n    /**\n     * Remove oncontextmenu=() => {} from the divWheel element\n     */\n    disableOnContextMenu?: boolean;\n\n    /**\n     * div to attach the wheel event\n     *\n     * @default document.body\n     */\n    divWheel?: HTMLElement;\n\n    /**\n     * Use this PIXI.ticker for updates\n     *\n     * @default PIXI.Ticker.shared\n     */\n    ticker?: Ticker;\n}\n\nexport interface ICompleteViewportOptions extends IViewportOptions {\n    screenWidth: number;\n    screenHeight: number;\n    threshold: number;\n    passiveWheel: boolean;\n    stopPropagation: boolean;\n    noTicker: boolean;\n    ticker: Ticker;\n}\n\nexport interface IViewportTransformState {\n    x: number;\n    y: number;\n    scaleX: number;\n    scaleY: number;\n}\n\nconst DEFAULT_VIEWPORT_OPTIONS: ICompleteViewportOptions = {\n    screenWidth: window.innerWidth,\n    screenHeight: window.innerHeight,\n    worldWidth: null,\n    worldHeight: null,\n    threshold: 5,\n    passiveWheel: true,\n    stopPropagation: false,\n    forceHitArea: null,\n    noTicker: false,\n    interaction: null,\n    disableOnContextMenu: false,\n    ticker: Ticker.shared,\n};\n\n/**\n * Main class to use when creating a Viewport\n *\n * @public\n * @fires clicked\n * @fires drag-start\n * @fires drag-end\n * @fires drag-remove\n * @fires pinch-start\n * @fires pinch-end\n * @fires pinch-remove\n * @fires snap-start\n * @fires snap-end\n * @fires snap-remove\n * @fires snap-zoom-start\n * @fires snap-zoom-end\n * @fires snap-zoom-remove\n * @fires bounce-x-start\n * @fires bounce-x-end\n * @fires bounce-y-start\n * @fires bounce-y-end\n * @fires bounce-remove\n * @fires wheel\n * @fires wheel-remove\n * @fires wheel-scroll\n * @fires wheel-scroll-remove\n * @fires mouse-edge-start\n * @fires mouse-edge-end\n * @fires mouse-edge-remove\n * @fires moved\n * @fires moved-end\n * @fires zoomed\n * @fires zoomed-end\n * @fires frame-end\n */\nexport class Viewport extends Container\n{\n    /** Flags whether the viewport is being panned */\n    public moving?: boolean;\n\n    public screenWidth: number;\n    public screenHeight: number;\n\n    /** Number of pixels to move to trigger an input event (e.g., drag, pinch) or disable a clicked event */\n    public threshold: number;\n\n    public readonly input: InputManager;\n\n    /** Use this to add user plugins or access existing plugins (e.g., to pause, resume, or remove them) */\n    public readonly plugins: PluginManager;\n\n    /** Flags whether the viewport zoom is being changed. */\n    public zooming?: boolean;\n\n    public lastViewport?: IViewportTransformState | null;\n\n    /** The options passed when creating this viewport, merged with the default values */\n    public readonly options: ICompleteViewportOptions & { divWheel: HTMLElement };\n\n    private _dirty?: boolean;\n    private _forceHitArea?: IHitArea | null;\n    private _hitAreaDefault?: Rectangle;\n    private _pause?: boolean;\n    private readonly tickerFunction?: () => void;\n    private _worldWidth?: number | null;\n    private _worldHeight?: number | null;\n    private _disableOnContextMenu = (e: MouseEvent) => e.preventDefault();\n\n    /**\n     * @param {IViewportOptions} ViewportOptions\n     * @param {number} [options.screenWidth=window.innerWidth]\n     * @param {number} [options.screenHeight=window.innerHeight]\n     * @param {number} [options.worldWidth=this.width]\n     * @param {number} [options.worldHeight=this.height]\n     * @param {number} [options.threshold=5] number of pixels to move to trigger an input event (e.g., drag, pinch)\n     * or disable a clicked event\n     * @param {boolean} [options.passiveWheel=true] whether the 'wheel' event is set to passive (note: if false,\n     * e.preventDefault() will be called when wheel is used over the viewport)\n     * @param {boolean} [options.stopPropagation=false] whether to stopPropagation of events that impact the viewport\n     * (except wheel events, see options.passiveWheel)\n     * @param {HitArea} [options.forceHitArea] change the default hitArea from world size to a new value\n     * @param {boolean} [options.noTicker] set this if you want to manually call update() function on each frame\n     * @param {PIXI.Ticker} [options.ticker=PIXI.Ticker.shared] use this PIXI.ticker for updates\n     * @param {PIXI.InteractionManager} [options.interaction=null] InteractionManager, available from instantiated\n     * WebGLRenderer/CanvasRenderer.plugins.interaction - used to calculate pointer position relative to canvas\n     * location on screen\n     * @param {HTMLElement} [options.divWheel=document.body] div to attach the wheel event\n     * @param {boolean} [options.disableOnContextMenu] remove oncontextmenu=() => {} from the divWheel element\n     */\n    constructor(options: IViewportOptions = {})\n    {\n        super();\n        this.options = Object.assign(\n            {},\n            { divWheel: document.body },\n            DEFAULT_VIEWPORT_OPTIONS,\n            options\n        );\n\n        this.screenWidth = this.options.screenWidth;\n        this.screenHeight = this.options.screenHeight;\n\n        this._worldWidth = this.options.worldWidth;\n        this._worldHeight = this.options.worldHeight;\n        this.forceHitArea = this.options.forceHitArea;\n        this.threshold = this.options.threshold;\n\n        this.options.divWheel = this.options.divWheel || document.body;\n\n        if (this.options.disableOnContextMenu)\n        {\n            this.options.divWheel.addEventListener('contextmenu', this._disableOnContextMenu);\n        }\n        if (!this.options.noTicker)\n        {\n            this.tickerFunction = () => this.update(this.options.ticker.elapsedMS);\n            this.options.ticker.add(this.tickerFunction);\n        }\n\n        this.input = new InputManager(this);\n        this.plugins = new PluginManager(this);\n        this.trackedPointers = [];\n    }\n\n    /** Overrides PIXI.Container's destroy to also remove the 'wheel' and PIXI.Ticker listeners */\n    destroy(options?: IDestroyOptions): void\n    {\n        if (!this.options.noTicker && this.tickerFunction)\n        {\n            this.options.ticker.remove(this.tickerFunction);\n        }\n        if (this.options.disableOnContextMenu)\n        {\n            this.options.divWheel.removeEventListener('contextmenu', this._disableOnContextMenu);\n        }\n\n        this.input.destroy();\n        super.destroy(options);\n    }\n\n    /**\n     * Update viewport on each frame.\n     *\n     * By default, you do not need to call this unless you set `options.noTicker=true`.\n     *\n     * @param {number} elapsed time in milliseconds since last update\n     */\n    update(elapsed: number): void\n    {\n        if (!this.pause)\n        {\n            this.plugins.update(elapsed);\n\n            if (this.lastViewport)\n            {\n                // Check for moved-end event\n                if (this.lastViewport.x !== this.x || this.lastViewport.y !== this.y)\n                {\n                    this.moving = true;\n                }\n                else if (this.moving)\n                {\n                    this.emit('moved-end', this);\n                    this.moving = false;\n                }\n\n                // Check for zoomed-end event\n                if (this.lastViewport.scaleX !== this.scale.x || this.lastViewport.scaleY !== this.scale.y)\n                {\n                    this.zooming = true;\n                }\n                else if (this.zooming)\n                {\n                    this.emit('zoomed-end', this);\n                    this.zooming = false;\n                }\n            }\n\n            if (!this.forceHitArea)\n            {\n                this._hitAreaDefault = new Rectangle(this.left, this.top, this.worldScreenWidth, this.worldScreenHeight);\n                this.hitArea = this._hitAreaDefault;\n            }\n\n            this._dirty = this._dirty || !this.lastViewport\n                || this.lastViewport.x !== this.x || this.lastViewport.y !== this.y\n                || this.lastViewport.scaleX !== this.scale.x || this.lastViewport.scaleY !== this.scale.y;\n\n            this.lastViewport = {\n                x: this.x,\n                y: this.y,\n                scaleX: this.scale.x,\n                scaleY: this.scale.y\n            };\n            this.emit('frame-end', this);\n        }\n    }\n\n    /** Use this to set screen and world sizes, needed for pinch/wheel/clamp/bounce. */\n    resize(\n        screenWidth = window.innerWidth,\n        screenHeight = window.innerHeight,\n        worldWidth?: number,\n        worldHeight?: number\n    ): void\n    {\n        this.screenWidth = screenWidth;\n        this.screenHeight = screenHeight;\n\n        if (typeof worldWidth !== 'undefined')\n        {\n            this._worldWidth = worldWidth;\n        }\n        if (typeof worldHeight !== 'undefined')\n        {\n            this._worldHeight = worldHeight;\n        }\n\n        this.plugins.resize();\n        this.dirty = true;\n    }\n\n    /** World width, in pixels */\n    get worldWidth(): number\n    {\n        if (this._worldWidth)\n        {\n            return this._worldWidth;\n        }\n\n        return this.width / this.scale.x;\n    }\n    set worldWidth(value: number)\n    {\n        this._worldWidth = value;\n        this.plugins.resize();\n    }\n\n    /** World height, in pixels */\n    get worldHeight(): number\n    {\n        if (this._worldHeight)\n        {\n            return this._worldHeight;\n        }\n\n        return this.height / this.scale.y;\n    }\n    set worldHeight(value: number)\n    {\n        this._worldHeight = value;\n        this.plugins.resize();\n    }\n\n    /** Get visible world bounds of viewport */\n    public getVisibleBounds(): Rectangle\n    {\n        return new Rectangle(this.left, this.top, this.worldScreenWidth, this.worldScreenHeight);\n    }\n\n    /** Change coordinates from screen to world */\n    public toWorld(x: number, y: number): Point;\n    /** Change coordinates from screen to world */\n    public toWorld(screenPoint: Point): Point;\n\n    public toWorld(x: number | Point, y?: number): Point\n    {\n        if (arguments.length === 2)\n        {\n            return this.toLocal(new Point(x as number, y));\n        }\n\n        return this.toLocal(x as Point);\n    }\n\n    /** Change coordinates from world to screen */\n    public toScreen(x: number, y: number): Point;\n    /** Change coordinates from world to screen */\n    public toScreen(worldPoint: Point): Point;\n\n    public toScreen(x: number | Point, y?: number): Point\n    {\n        if (arguments.length === 2)\n        {\n            return this.toGlobal(new Point(x as number, y));\n        }\n\n        return this.toGlobal(x as Point);\n    }\n\n    /** Screen width in world coordinates */\n    get worldScreenWidth(): number\n    {\n        return this.screenWidth / this.scale.x;\n    }\n\n    /** Screen height in world coordinates */\n    get worldScreenHeight(): number\n    {\n        return this.screenHeight / this.scale.y;\n    }\n\n    /** World width in screen coordinates */\n    get screenWorldWidth(): number\n    {\n        return this.worldWidth * this.scale.x;\n    }\n\n    /** World height in screen coordinates */\n    get screenWorldHeight(): number\n    {\n        return this.worldHeight * this.scale.y;\n    }\n\n    /** Center of screen in world coordinates */\n    get center(): Point\n    {\n        return new Point(\n            (this.worldScreenWidth / 2) - (this.x / this.scale.x),\n            (this.worldScreenHeight / 2) - (this.y / this.scale.y),\n        );\n    }\n    set center(value: Point)\n    {\n        this.moveCenter(value);\n    }\n\n    /** Move center of viewport to (x, y) */\n    public moveCenter(x: number, y: number): Viewport;\n\n    /** Move center of viewport to {@code center}. */\n    public moveCenter(center: Point): Viewport;\n\n    public moveCenter(...args: [number, number] | [Point]): Viewport\n    {\n        let x: number;\n        let y: number;\n\n        if (typeof args[0] === 'number')\n        {\n            x = args[0];\n            y = args[1] as number;\n        }\n        else\n        {\n            x = args[0].x;\n            y = args[0].y;\n        }\n\n        const newX = ((this.worldScreenWidth / 2) - x) * this.scale.x;\n        const newY = ((this.worldScreenHeight / 2) - y) * this.scale.y;\n\n        if (this.x !== newX || this.y !== newY)\n        {\n            this.position.set(newX, newY);\n            this.plugins.reset();\n            this.dirty = true;\n        }\n\n        return this;\n    }\n\n    /** Top-left corner of Viewport */\n    get corner(): Point\n    {\n        return new Point(-this.x / this.scale.x, -this.y / this.scale.y);\n    }\n    set corner(value: Point)\n    {\n        this.moveCorner(value);\n    }\n\n    /** Move Viewport's top-left corner; also clamps and resets decelerate and bounce (as needed) */\n    public moveCorner(x: number, y: number): Viewport;\n\n    /** move Viewport's top-left corner; also clamps and resets decelerate and bounce (as needed) */\n    public moveCorner(center: Point): Viewport;\n\n    public moveCorner(...args: [number, number] | [Point]): Viewport\n    {\n        let x;\n        let y;\n\n        if (args.length === 1)\n        {\n            x = -args[0].x * this.scale.x;\n            y = -args[0].y * this.scale.y;\n        }\n        else\n        {\n            x = -args[0] * this.scale.x;\n            y = -args[1] * this.scale.y;\n        }\n\n        if (x !== this.x || y !== this.y)\n        {\n            this.position.set(x, y);\n            this.plugins.reset();\n            this.dirty = true;\n        }\n\n        return this;\n    }\n\n    /** Get how many world pixels fit in screen's width */\n    get screenWidthInWorldPixels(): number\n    {\n        return this.screenWidth / this.scale.x;\n    }\n\n    /** Get how many world pixels fit on screen's height */\n    get screenHeightInWorldPixels(): number\n    {\n        return this.screenHeight / this.scale.y;\n    }\n\n    /**\n     * Find the scale value that fits a world width on the screen\n     * does not change the viewport (use fit... to change)\n     *\n     * @param width - Width in world pixels\n     * @return - scale\n     */\n    findFitWidth(width: number): number\n    {\n        return this.screenWidth / width;\n    }\n\n    /**\n     * Finds the scale value that fits a world height on the screens\n     * does not change the viewport (use fit... to change)\n     *\n     * @param height - Height in world pixels\n     * @return - scale\n     */\n    findFitHeight(height: number): number\n    {\n        return this.screenHeight / height;\n    }\n\n    /**\n     * Finds the scale value that fits the smaller of a world width and world height on the screen\n     * does not change the viewport (use fit... to change)\n     *\n     * @param {number} width in world pixels\n     * @param {number} height in world pixels\n     * @returns {number} scale\n     */\n    findFit(width: number, height: number): number\n    {\n        const scaleX = this.screenWidth / width;\n        const scaleY = this.screenHeight / height;\n\n        return Math.min(scaleX, scaleY);\n    }\n\n    /**\n     * Finds the scale value that fits the larger of a world width and world height on the screen\n     * does not change the viewport (use fit... to change)\n     *\n     * @param {number} width in world pixels\n     * @param {number} height in world pixels\n     * @returns {number} scale\n     */\n    findCover(width: number, height: number): number\n    {\n        const scaleX = this.screenWidth / width;\n        const scaleY = this.screenHeight / height;\n\n        return Math.max(scaleX, scaleY);\n    }\n\n    /**\n     * Change zoom so the width fits in the viewport\n     *\n     * @param width - width in world coordinates\n     * @param center - maintain the same center\n     * @param scaleY - whether to set scaleY=scaleX\n     * @param noClamp - whether to disable clamp-zoom\n     * @returns {Viewport} this\n     */\n    fitWidth(width = this.worldWidth, center?: boolean, scaleY = true, noClamp?: boolean): Viewport\n    {\n        let save: Point | undefined;\n\n        if (center)\n        {\n            save = this.center;\n        }\n        this.scale.x = this.screenWidth / width;\n\n        if (scaleY)\n        {\n            this.scale.y = this.scale.x;\n        }\n\n        const clampZoom = this.plugins.get('clamp-zoom', true);\n\n        if (!noClamp && clampZoom)\n        {\n            clampZoom.clamp();\n        }\n\n        if (center && save)\n        {\n            this.moveCenter(save);\n        }\n\n        return this;\n    }\n\n    /**\n     * Change zoom so the height fits in the viewport\n     *\n     * @param {number} [height=this.worldHeight] in world coordinates\n     * @param {boolean} [center] maintain the same center of the screen after zoom\n     * @param {boolean} [scaleX=true] whether to set scaleX = scaleY\n     * @param {boolean} [noClamp] whether to disable clamp-zoom\n     * @returns {Viewport} this\n     */\n    fitHeight(height = this.worldHeight, center?: boolean, scaleX = true, noClamp?: boolean): Viewport\n    {\n        let save: Point | undefined;\n\n        if (center)\n        {\n            save = this.center;\n        }\n        this.scale.y = this.screenHeight / height;\n\n        if (scaleX)\n        {\n            this.scale.x = this.scale.y;\n        }\n\n        const clampZoom = this.plugins.get('clamp-zoom', true);\n\n        if (!noClamp && clampZoom)\n        {\n            clampZoom.clamp();\n        }\n\n        if (center && save)\n        {\n            this.moveCenter(save);\n        }\n\n        return this;\n    }\n\n    /**\n     * Change zoom so it fits the entire world in the viewport\n     *\n     * @param {boolean} center maintain the same center of the screen after zoom\n     * @returns {Viewport} this\n     */\n    fitWorld(center?: boolean): Viewport\n    {\n        let save: Point | undefined;\n\n        if (center)\n        {\n            save = this.center;\n        }\n\n        this.scale.x = this.screenWidth / this.worldWidth;\n        this.scale.y = this.screenHeight / this.worldHeight;\n\n        if (this.scale.x < this.scale.y)\n        {\n            this.scale.y = this.scale.x;\n        }\n        else\n        {\n            this.scale.x = this.scale.y;\n        }\n\n        const clampZoom = this.plugins.get('clamp-zoom', true);\n\n        if (clampZoom)\n        {\n            clampZoom.clamp();\n        }\n\n        if (center && save)\n        {\n            this.moveCenter(save);\n        }\n\n        return this;\n    }\n\n    /**\n     * Change zoom so it fits the size or the entire world in the viewport\n     *\n     * @param {boolean} [center] maintain the same center of the screen after zoom\n     * @param {number} [width=this.worldWidth] desired width\n     * @param {number} [height=this.worldHeight] desired height\n     * @returns {Viewport} this\n     */\n    fit(center?: boolean, width = this.worldWidth, height = this.worldHeight): Viewport\n    {\n        let save: Point | undefined;\n\n        if (center)\n        {\n            save = this.center;\n        }\n\n        this.scale.x = this.screenWidth / width;\n        this.scale.y = this.screenHeight / height;\n\n        if (this.scale.x < this.scale.y)\n        {\n            this.scale.y = this.scale.x;\n        }\n        else\n        {\n            this.scale.x = this.scale.y;\n        }\n        const clampZoom = this.plugins.get('clamp-zoom', true);\n\n        if (clampZoom)\n        {\n            clampZoom.clamp();\n        }\n        if (center && save)\n        {\n            this.moveCenter(save);\n        }\n\n        return this;\n    }\n\n    // this doesn't work\n    // set visible(value: boolean)\n    // {\n    //     console.log('hello!');\n    //     if (!value)\n    //     {\n    //         debugger;\n    //         this.input.clear();\n    //     }\n    //     super.visible = value;\n    // }\n\n    // get visible(): boolean\n    // {\n    //     return super.visible;\n    // }\n\n    /**\n     * Zoom viewport to specific value.\n     *\n     * @param {number} scale value (e.g., 1 would be 100%, 0.25 would be 25%)\n     * @param {boolean} [center] maintain the same center of the screen after zoom\n     * @return {Viewport} this\n     */\n    setZoom(scale: number, center?: boolean): Viewport\n    {\n        let save;\n\n        if (center)\n        {\n            save = this.center;\n        }\n        this.scale.set(scale);\n        const clampZoom = this.plugins.get('clamp-zoom', true);\n\n        if (clampZoom)\n        {\n            clampZoom.clamp();\n        }\n        if (center && save)\n        {\n            this.moveCenter(save);\n        }\n\n        return this;\n    }\n\n    /**\n     * Zoom viewport by a certain percent (in both x and y direction).\n     *\n     * @param {number} percent change (e.g., 0.25 would increase a starting scale of 1.0 to 1.25)\n     * @param {boolean} [center] maintain the same center of the screen after zoom\n     * @return {Viewport} this\n     */\n    zoomPercent(percent: number, center?: boolean): Viewport\n    {\n        return this.setZoom(this.scale.x + (this.scale.x * percent), center);\n    }\n\n    /**\n     * Zoom viewport by increasing/decreasing width by a certain number of pixels.\n     *\n     * @param {number} change in pixels\n     * @param {boolean} [center] maintain the same center of the screen after zoom\n     * @return {Viewport} this\n     */\n    zoom(change: number, center?: boolean): Viewport\n    {\n        this.fitWidth(change + this.worldScreenWidth, center);\n\n        return this;\n    }\n\n    /** Changes scale of viewport and maintains center of viewport */\n    get scaled(): number\n    {\n        return this.scale.x;\n    }\n    set scaled(scale: number)\n    {\n        this.setZoom(scale, true);\n    }\n\n    /**\n     * Returns zoom to the desired scale\n     *\n     * @param {ISnapZoomOptions} options\n     * @param {number} [options.width=0] - the desired width to snap (to maintain aspect ratio, choose width or height)\n     * @param {number} [options.height=0] - the desired height to snap (to maintain aspect ratio, choose width or height)\n     * @param {number} [options.time=1000] - time for snapping in ms\n     * @param {(string|function)} [options.ease=easeInOutSine] ease function or name (see http://easings.net/\n     *   for supported names)\n     * @param {PIXI.Point} [options.center] - place this point at center during zoom instead of center of the viewport\n     * @param {boolean} [options.interrupt=true] - pause snapping with any user input on the viewport\n     * @param {boolean} [options.removeOnComplete] - removes this plugin after snapping is complete\n     * @param {boolean} [options.removeOnInterrupt] - removes this plugin if interrupted by any user input\n     * @param {boolean} [options.forceStart] - starts the snap immediately regardless of whether the viewport is at the\n     *   desired zoom\n     * @param {boolean} [options.noMove] - zoom but do not move\n     */\n    snapZoom(options?: ISnapZoomOptions): Viewport\n    {\n        this.plugins.add('snap-zoom', new SnapZoom(this, options));\n\n        return this;\n    }\n\n    /** Is container out of world bounds */\n    OOB(): {\n        left: boolean;\n        right: boolean;\n        top: boolean;\n        bottom: boolean;\n        cornerPoint: Point;\n        }\n    {\n        return {\n            left: this.left < 0,\n            right: this.right > this.worldWidth,\n            top: this.top < 0,\n            bottom: this.bottom > this.worldHeight,\n            cornerPoint: new Point(\n                (this.worldWidth * this.scale.x) - this.screenWidth,\n                (this.worldHeight * this.scale.y) - this.screenHeight\n            )\n        };\n    }\n\n    /** World coordinates of the right edge of the screen */\n    get right(): number\n    {\n        return (-this.x / this.scale.x) + this.worldScreenWidth;\n    }\n    set right(value: number)\n    {\n        this.x = (-value * this.scale.x) + this.screenWidth;\n        this.plugins.reset();\n    }\n\n    /** World coordinates of the left edge of the screen */\n    get left(): number\n    {\n        return -this.x / this.scale.x;\n    }\n    set left(value: number)\n    {\n        this.x = -value * this.scale.x;\n        this.plugins.reset();\n    }\n\n    /** World coordinates of the top edge of the screen */\n    get top(): number\n    {\n        return -this.y / this.scale.y;\n    }\n    set top(value: number)\n    {\n        this.y = -value * this.scale.y;\n        this.plugins.reset();\n    }\n\n    /** World coordinates of the bottom edge of the screen */\n    get bottom(): number\n    {\n        return (-this.y / this.scale.y) + this.worldScreenHeight;\n    }\n    set bottom(value: number)\n    {\n        this.y = (-value * this.scale.y) + this.screenHeight;\n        this.plugins.reset();\n    }\n\n    /**\n     * Determines whether the viewport is dirty (i.e., needs to be rendered to the screen because of a change)\n     */\n    get dirty(): boolean\n    {\n        return !!this._dirty;\n    }\n    set dirty(value: boolean)\n    {\n        this._dirty = value;\n    }\n\n    /**\n     * Permanently changes the Viewport's hitArea\n     *\n     * NOTE: if not set then hitArea = PIXI.Rectangle(Viewport.left, Viewport.top, Viewport.worldScreenWidth,\n     * Viewport.worldScreenHeight)\n     */\n    get forceHitArea(): IHitArea | null | undefined\n    {\n        return this._forceHitArea;\n    }\n    set forceHitArea(value: IHitArea | null | undefined)\n    {\n        if (value)\n        {\n            this._forceHitArea = value;\n            this.hitArea = value;\n        }\n        else\n        {\n            this._forceHitArea = null;\n            this.hitArea = new Rectangle(0, 0, this.worldWidth, this.worldHeight);\n        }\n    }\n\n    /**\n     * Enable one-finger touch to drag\n     *\n     * NOTE: if you expect users to use right-click dragging, you should enable `viewport.options.disableOnContextMenu`\n     * to avoid the context menu popping up on each right-click drag.\n     *\n     * @param {IDragOptions} [options]\n     * @param {string} [options.direction=all] direction to drag\n     * @param {boolean} [options.pressDrag=true] whether click to drag is active\n     * @param {boolean} [options.wheel=true] use wheel to scroll in direction (unless wheel plugin is active)\n     * @param {number} [options.wheelScroll=1] number of pixels to scroll with each wheel spin\n     * @param {boolean} [options.reverse] reverse the direction of the wheel scroll\n     * @param {(boolean|string)} [options.clampWheel=false] clamp wheel(to avoid weird bounce with mouse wheel)\n     * @param {string} [options.underflow=center] where to place world if too small for screen\n     * @param {number} [options.factor=1] factor to multiply drag to increase the speed of movement\n     * @param {string} [options.mouseButtons=all] changes which mouse buttons trigger drag, use: 'all', 'left',\n     *  'right' 'middle', or some combination, like, 'middle-right'; you may want to set\n     *   viewport.options.disableOnContextMenu if you want to use right-click dragging\n     * @param {string[]} [options.keyToPress=null] - array containing\n     *  {@link key|https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code} codes of keys that can be\n     *  pressed for the drag to be triggered, e.g.: ['ShiftLeft', 'ShiftRight'}.\n     * @param {boolean} [options.ignoreKeyToPressOnTouch=false] - ignore keyToPress for touch events\n     * @param {number} [options.lineHeight=20] - scaling factor for non-DOM_DELTA_PIXEL scrolling events\n     * @returns {Viewport} this\n     */\n    public drag(options?: IDragOptions): Viewport\n    {\n        this.plugins.add('drag', new Drag(this, options));\n\n        return this;\n    }\n\n    /**\n     * Clamp to world boundaries or other provided boundaries\n     * There are three ways to clamp:\n     * 1. direction: 'all' = the world is clamped to its world boundaries, ie, you cannot drag any part of offscreen\n     *    direction: 'x' | 'y' = only the x or y direction is clamped to its world boundary\n     * 2. left, right, top, bottom = true | number = the world is clamped to the world's pixel location for each side;\n     *    if any of these are set to true, then the location is set to the boundary\n     *    [0, viewport.worldWidth/viewport.worldHeight], eg: to allow the world to be completely dragged offscreen,\n     *    set [-viewport.worldWidth, -viewport.worldHeight, viewport.worldWidth * 2, viewport.worldHeight * 2]\n     *\n     * Underflow determines what happens when the world is smaller than the viewport\n     * 1. none = the world is clamped but there is no special behavior\n     * 2. center = the world is centered on the viewport\n     * 3. combination of top/bottom/center and left/right/center (case insensitive) = the world is stuck to the\n     *     appropriate boundaries\n     *\n     * NOTES:\n     *   clamp is disabled if called with no options; use { direction: 'all' } for all edge clamping\n     *   screenWidth, screenHeight, worldWidth, and worldHeight needs to be set for this to work properly\n     *\n     * @param {object} [options]\n     * @param {(number|boolean)} [options.left=false] - clamp left; true = 0\n     * @param {(number|boolean)} [options.right=false] - clamp right; true = viewport.worldWidth\n     * @param {(number|boolean)} [options.top=false] - clamp top; true = 0\n     * @param {(number|boolean)} [options.bottom=false] - clamp bottom; true = viewport.worldHeight\n     * @param {string} [direction] - (all, x, or y) using clamps of [0, viewport.worldWidth/viewport.worldHeight];\n     *  replaces left/right/top/bottom if set\n     * @param {string} [underflow=center] - where to place world if too small for screen (e.g., top-right, center,\n     *  none, bottomLeft)     * @returns {Viewport} this\n     */\n    public clamp(options?: IClampOptions): Viewport\n    {\n        this.plugins.add('clamp', new Clamp(this, options));\n\n        return this;\n    }\n\n    /**\n     * Decelerate after a move\n     *\n     * NOTE: this fires 'moved' event during deceleration\n     *\n     * @param {IDecelerateOptions} [options]\n     * @param {number} [options.friction=0.95] - percent to decelerate after movement\n     * @param {number} [options.bounce=0.8] - percent to decelerate when past boundaries (only applicable when\n     *   viewport.bounce() is active)\n     * @param {number} [options.minSpeed=0.01] - minimum velocity before stopping/reversing acceleration\n     * @return {Viewport} this\n     */\n    public decelerate(options?: IDecelerateOptions): Viewport\n    {\n        this.plugins.add('decelerate', new Decelerate(this, options));\n\n        return this;\n    }\n\n    /**\n     * Bounce on borders\n     * NOTES:\n     *    screenWidth, screenHeight, worldWidth, and worldHeight needs to be set for this to work properly\n     *    fires 'moved', 'bounce-x-start', 'bounce-y-start', 'bounce-x-end', and 'bounce-y-end' events\n     * @param {object} [options]\n     * @param {string} [options.sides=all] - all, horizontal, vertical, or combination of top, bottom, right, left\n     *  (e.g., 'top-bottom-right')\n     * @param {number} [options.friction=0.5] - friction to apply to decelerate if active\n     * @param {number} [options.time=150] - time in ms to finish bounce\n     * @param {object} [options.bounceBox] - use this bounceBox instead of (0, 0, viewport.worldWidth, viewport.worldHeight)\n     * @param {number} [options.bounceBox.x=0]\n     * @param {number} [options.bounceBox.y=0]\n     * @param {number} [options.bounceBox.width=viewport.worldWidth]\n     * @param {number} [options.bounceBox.height=viewport.worldHeight]\n     * @param {string|function} [options.ease=easeInOutSine] - ease function or name\n     *  (see http://easings.net/ for supported names)\n     * @param {string} [options.underflow=center] - (top/bottom/center and left/right/center, or center)\n     *  where to place world if too small for screen\n     * @return {Viewport} this\n     */\n    public bounce(options?: IBounceOptions): Viewport\n    {\n        this.plugins.add('bounce', new Bounce(this, options));\n\n        return this;\n    }\n\n    /**\n     * Enable pinch to zoom and two-finger touch to drag\n     *\n     * @param {PinchOptions} [options]\n     * @param {boolean} [options.noDrag] - disable two-finger dragging\n     * @param {number} [options.percent=1] - percent to modify pinch speed\n     * @param {number} [options.factor=1] - factor to multiply two-finger drag to increase the speed of movement\n     * @param {PIXI.Point} [options.center] - place this point at center during zoom instead of center of two fingers\n     * @param {('all'|'x'|'y')} [options.axis=all] - axis to zoom\n     * @return {Viewport} this\n     */\n    public pinch(options?: IPinchOptions): Viewport\n    {\n        this.plugins.add('pinch', new Pinch(this, options));\n\n        return this;\n    }\n\n    /**\n     * Snap to a point\n     *\n     * @param {number} x\n     * @param {number} y\n     * @param {ISnapOptions} [options]\n     * @param {boolean} [options.topLeft] - snap to the top-left of viewport instead of center\n     * @param {number} [options.friction=0.8] - friction/frame to apply if decelerate is active\n     * @param {number} [options.time=1000] - time in ms to snap\n     * @param {string|function} [options.ease=easeInOutSine] - ease function or name (see http://easings.net/\n     *   for supported names)\n     * @param {boolean} [options.interrupt=true] - pause snapping with any user input on the viewport\n     * @param {boolean} [options.removeOnComplete] - removes this plugin after snapping is complete\n     * @param {boolean} [options.removeOnInterrupt] - removes this plugin if interrupted by any user input\n     * @param {boolean} [options.forceStart] - starts the snap immediately regardless of whether the viewport is at\n     *   the desired location\n     * @return {Viewport} this\n     */\n    public snap(x: number, y: number, options?: ISnapOptions): Viewport\n    {\n        this.plugins.add('snap', new Snap(this, x, y, options));\n\n        return this;\n    }\n\n    /**\n     * Follow a target\n     *\n     * NOTES:\n     *    uses the (x, y) as the center to follow; for PIXI.Sprite to work properly, use sprite.anchor.set(0.5)\n     *    options.acceleration is not perfect as it doesn't know the velocity of the target. It adds acceleration\n     *    to the start of movement and deceleration to the end of movement when the target is stopped.\n     *    To cancel the follow, use: `viewport.plugins.remove('follow')`\n     *\n     * @fires 'moved' event\n     *\n     * @param {PIXI.DisplayObject} target to follow\n     * @param {IFollowOptions} [options]\n     * @param {number} [options.speed=0] - to follow in pixels/frame (0=teleport to location)\n     * @param {number} [options.acceleration] - set acceleration to accelerate and decelerate at this rate; speed\n     *   cannot be 0 to use acceleration\n     * @param {number} [options.radius] - radius (in world coordinates) of center circle where movement is allowed\n     *   without moving the viewport     * @returns {Viewport} this\n     * @returns {Viewport} this\n     */\n    public follow(target: DisplayObject, options?: IFollowOptions): Viewport\n    {\n        this.plugins.add('follow', new Follow(this, target, options));\n\n        return this;\n    }\n\n    /**\n     * Zoom using mouse wheel\n     *\n     * NOTE: the default event listener for 'wheel' event is document.body. Use `Viewport.options.divWheel` to\n     * change this default\n     *\n     * @param {IWheelOptions} [options]\n     * @param {number} [options.percent=0.1] - percent to scroll with each spin\n     * @param {number} [options.smooth] - smooth the zooming by providing the number of frames to zoom between wheel spins\n     * @param {boolean} [options.interrupt=true] - stop smoothing with any user input on the viewport\n     * @param {boolean} [options.reverse] - reverse the direction of the scroll\n     * @param {PIXI.Point} [options.center] - place this point at center during zoom instead of current mouse position\n     * @param {number} [options.lineHeight=20] - scaling factor for non-DOM_DELTA_PIXEL scrolling events\n     * @param {('all'|'x'|'y')} [options.axis=all] - axis to zoom\n     * @return {Viewport} this\n     */\n    public wheel(options?: IWheelOptions): Viewport\n    {\n        this.plugins.add('wheel', new Wheel(this, options));\n\n        return this;\n    }\n\n    /**\n     * Animate the position and/or scale of the viewport\n     * To set the zoom level, use: (1) scale, (2) scaleX and scaleY, or (3) width and/or height\n     * @params {object} options\n     * @params {number} [options.time=1000] - time to animate\n     * @params {PIXI.Point} [options.position=viewport.center] - position to move viewport\n     * @params {number} [options.width] - desired viewport width in world pixels (use instead of scale;\n     *  aspect ratio is maintained if height is not provided)\n     * @params {number} [options.height] - desired viewport height in world pixels (use instead of scale;\n     *  aspect ratio is maintained if width is not provided)\n     * @params {number} [options.scale] - scale to change zoom (scale.x = scale.y)\n     * @params {number} [options.scaleX] - independently change zoom in x-direction\n     * @params {number} [options.scaleY] - independently change zoom in y-direction\n     * @params {(function|string)} [options.ease=linear] - easing function to use\n     * @params {function} [options.callbackOnComplete]\n     * @params {boolean} [options.removeOnInterrupt] removes this plugin if interrupted by any user input\n     * @returns {Viewport} this\n     */\n    public animate(options: IAnimateOptions): Viewport\n    {\n        this.plugins.add('animate', new Animate(this, options));\n\n        return this;\n    }\n\n    /**\n     * Enable clamping of zoom to constraints\n     *\n     * The minWidth/Height settings are how small the world can get (as it would appear on the screen)\n     * before clamping. The maxWidth/maxHeight is how larger the world can scale (as it would appear on\n     * the screen) before clamping.\n     *\n     * For example, if you have a world size of 1000 x 1000 and a screen size of 100 x 100, if you set\n     * minWidth/Height = 100 then the world will not be able to zoom smaller than the screen size (ie,\n     * zooming out so it appears smaller than the screen). Similarly, if you set maxWidth/Height = 100\n     * the world will not be able to zoom larger than the screen size (ie, zooming in so it appears\n     * larger than the screen).\n     *\n     * @param {object} [options]\n     * @param {number} [options.minWidth] - minimum width\n     * @param {number} [options.minHeight] - minimum height\n     * @param {number} [options.maxWidth] - maximum width\n     * @param {number} [options.maxHeight] - maximum height\n     * @param {number} [options.minScale] - minimum scale\n     * @param {number} [options.maxScale] - minimum scale\n     * @return {Viewport} this\n     */\n    public clampZoom(options: IClampZoomOptions): Viewport\n    {\n        this.plugins.add('clamp-zoom', new ClampZoom(this, options));\n\n        return this;\n    }\n\n    /**\n     * Scroll viewport when mouse hovers near one of the edges or radius-distance from center of screen.\n     *\n     * NOTES: fires 'moved' event; there's a known bug where the mouseEdges does not work properly with \"windowed\" viewports\n     *\n     * @param {IMouseEdgesOptions} [options]\n     * @param {number} [options.radius] - distance from center of screen in screen pixels\n     * @param {number} [options.distance] - distance from all sides in screen pixels\n     * @param {number} [options.top] - alternatively, set top distance (leave unset for no top scroll)\n     * @param {number} [options.bottom] - alternatively, set bottom distance (leave unset for no top scroll)\n     * @param {number} [options.left] - alternatively, set left distance (leave unset for no top scroll)\n     * @param {number} [options.right] - alternatively, set right distance (leave unset for no top scroll)\n     * @param {number} [options.speed=8] - speed in pixels/frame to scroll viewport\n     * @param {boolean} [options.reverse] - reverse direction of scroll\n     * @param {boolean} [options.noDecelerate] - don't use decelerate plugin even if it's installed\n     * @param {boolean} [options.linear] - if using radius, use linear movement (+/- 1, +/- 1) instead of angled\n     *   movement (Math.cos(angle from center), Math.sin(angle from center))\n     * @param {boolean} [options.allowButtons] allows plugin to continue working even when there's a mousedown event\n     */\n    public mouseEdges(options: IMouseEdgesOptions): Viewport\n    {\n        this.plugins.add('mouse-edges', new MouseEdges(this, options));\n\n        return this;\n    }\n\n    /** Pause viewport (including animation updates such as decelerate) */\n    get pause(): boolean\n    {\n        return !!this._pause;\n    }\n    set pause(value: boolean)\n    {\n        this._pause = value;\n\n        this.lastViewport = null;\n        this.moving = false;\n        this.zooming = false;\n\n        if (value)\n        {\n            this.input.pause();\n        }\n    }\n\n    /**\n     * Move the viewport so the bounding box is visible\n     *\n     * @param x - left\n     * @param y - top\n     * @param width\n     * @param height\n     * @param resizeToFit - Resize the viewport so the box fits within the viewport\n     */\n    public ensureVisible(x: number, y: number, width: number, height: number, resizeToFit?: boolean): void\n    {\n        if (resizeToFit && (width > this.worldScreenWidth || height > this.worldScreenHeight))\n        {\n            this.fit(true, width, height);\n            this.emit('zoomed', { viewport: this, type: 'ensureVisible' });\n        }\n        let moved = false;\n\n        if (x < this.left)\n        {\n            this.left = x;\n            moved = true;\n        }\n        else if (x + width > this.right)\n        {\n            this.right = x + width;\n            moved = true;\n        }\n        if (y < this.top)\n        {\n            this.top = y;\n            moved = true;\n        }\n        else if (y + height > this.bottom)\n        {\n            this.bottom = y + height;\n            moved = true;\n        }\n        if (moved)\n        {\n            this.emit('moved', { viewport: this, type: 'ensureVisible' });\n        }\n    }\n}\n\n/**\n * Fires after a mouse or touch click\n * @event Viewport#clicked\n * @type {object}\n * @property {PIXI.Point} screen\n * @property {PIXI.Point} world\n * @property {Viewport} viewport\n */\n\n/**\n * Fires when a drag starts\n * @event Viewport#drag-start\n * @type {object}\n * @property {PIXI.Point} screen\n * @property {PIXI.Point} world\n * @property {Viewport} viewport\n */\n\n/**\n * Fires when a drag ends\n * @event Viewport#drag-end\n * @type {object}\n * @property {PIXI.Point} screen\n * @property {PIXI.Point} world\n * @property {Viewport} viewport\n */\n\n/**\n * Fires when a pinch starts\n * @event Viewport#pinch-start\n * @type {Viewport}\n */\n\n/**\n * Fires when a pinch end\n * @event Viewport#pinch-end\n * @type {Viewport}\n */\n\n/**\n * Fires when a snap starts\n * @event Viewport#snap-start\n * @type {Viewport}\n */\n\n/**\n * Fires when a snap ends\n * @event Viewport#snap-end\n * @type {Viewport}\n */\n\n/**\n * Fires when a snap-zoom starts\n * @event Viewport#snap-zoom-start\n * @type {Viewport}\n */\n\n/**\n * Fires when a snap-zoom ends\n * @event Viewport#snap-zoom-end\n * @type {Viewport}\n */\n\n/**\n * Fires when a bounce starts in the x direction\n * @event Viewport#bounce-x-start\n * @type {Viewport}\n */\n\n/**\n * Fires when a bounce ends in the x direction\n * @event Viewport#bounce-x-end\n * @type {Viewport}\n */\n\n/**\n * Fires when a bounce starts in the y direction\n * @event Viewport#bounce-y-start\n * @type {Viewport}\n */\n\n/**\n * Fires when a bounce ends in the y direction\n * @event Viewport#bounce-y-end\n * @type {Viewport}\n */\n\n/**\n * Fires when for a mouse wheel event\n * @event Viewport#wheel\n * @type {object}\n * @property {object} wheel\n * @property {number} wheel.dx\n * @property {number} wheel.dy\n * @property {number} wheel.dz\n * @property {Viewport} viewport\n */\n\n/**\n * Fires when a wheel-scroll occurs\n * @event Viewport#wheel-scroll\n * @type {Viewport}\n */\n\n/**\n * Fires when a mouse-edge starts to scroll\n * @event Viewport#mouse-edge-start\n * @type {Viewport}\n */\n\n/**\n * Fires when the mouse-edge scrolling ends\n * @event Viewport#mouse-edge-end\n * @type {Viewport}\n */\n\n/**\n * Fires when viewport moves through UI interaction, deceleration, ensureVisible, or follow\n * @event Viewport#moved\n * @type {object}\n * @property {Viewport} viewport\n * @property {string} type - (drag, snap, pinch, follow, bounce-x, bounce-y,\n *  clamp-x, clamp-y, decelerate, mouse-edges, wheel, ensureVisible)\n */\n\n/**\n * Fires when viewport moves through UI interaction, deceleration, ensureVisible, or follow\n * @event Viewport#zoomed\n * @type {object}\n * @property {Viewport} viewport\n * @property {string} type (drag-zoom, pinch, wheel, clamp-zoom, ensureVisible)\n */\n\n/**\n * Fires when viewport stops moving\n * @event Viewport#moved-end\n * @type {Viewport}\n */\n\n/**\n * Fires when viewport stops zooming\n * @event Viewport#zoomed-end\n * @type {Viewport}\n */\n\n/**\n* Fires at the end of an update frame\n* @event Viewport#frame-end\n* @type {Viewport}\n*/\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;IAGA;IACA;IACA;IACA;IACA;;IAEA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;;IC1FA;AAGA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;ICpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;ygBC1RA;AACA;AACA;AACA;AACA;AACA;IACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;AACA;AACA;AACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;;IC3XA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA;IACA;AACA;IACA;IACA;AACA;AACA;AACA;AACA;AACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;;IC1RA;IACA;IACA;IACA;IACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;;IC7IA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;;IC1RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;ICpgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;ICvJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;;ICxRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;;IChKA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;ICxNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;;ICrRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;;ICvRA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;;ACrSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;;ICpRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;AACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;AACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;AACA;AACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;AACA;AACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;AACA;AACA;AACA;AACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}